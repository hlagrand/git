#!/bin/sh 
# Dont touch first 3 lines of this file \
: ${TCL_DEBUG="-n"}; exec TclSh ${TCL_DEBUG:+"$TCL_DEBUG"} "$0" ${1+"$@"}
# echo "$0: This is a TCL Library"; exit 1
# DELETE THIS LINE & IF TCL_LIBRARY: Delete line 3 + Uncomment line above !!!
#######  Tcl Script  ##########################################################
###
###      @(#)13/08/14 14:26:06, 7.622.1.3 /SccsBase/REL7/base/ccs/IoScripts/s.PPI-PlanPagXML
###      (C) Copyright 2011 CCI-Europe. Author : Rodney Miles (RM)
###
#######  Revision History  ####################################################
###      7.91.1.1 rm 2012/12/04 17:33:20                                    ###
###      194164 First delta of script linking PPI plans to CCI XMLPlanEnric ###
###      7.91.1.1 7.91.1.2 rm 2012/12/10 17:11:01                           ###
###      194577 Removal of calls to ReportPlanError.                        ###
###      7.91.1.2 7.91.1.3 rm 2013/08/13 16:39:30                           ###
###      206046 Calls to ConfigGetList reverted to calls to ConfigGetRecord ###
#######  End of Revisions  ####################################################

##=####  Tcl Procedure  #######################################################
###                       
###      NAME           : PPI-PlanPagXML 
###                       
###      SYNOPSIS       : The PPI/CCI XML interface. PPI plan files are 
###                       converted into CCI PlanXML format and passed on to
###                       the CCI XML Plan Enrichment spooler.
###                       
###      DESCRIPTION    : 
###                       
###      OPTIONS        : 
###                       
###      RETURN VALUE   : 0 - if OK
###                       1 - if error
###                       
##=############################################################################
# cmdtrace on [open /tmp/cmdtrace.log w]
set DEBUG [file exists /tmp/PPIXML-DEBUG]

loadccishared TclDOM

set THIS_SCRIPT PPI-PlanPagXML
set ErrProduct  ""

# Debugging variables is turned on/off be creating/deleting files in /tmp
# This means nothing has to be restartet.
#
# The files are:
# /tmp/PPI-DEBUG        - turns on debug log messages, leaves pageplans and
#                         extracted pageplans in /tmp.
# /tmp/PPI-DONTRUNPLANS - creates the pageplans without executing
# /tmp/PPI-NOTEMPLATES  - creates pageplans with no template pages
# /tmp/PPI-IGNOREDUMPVERSION - Turns off optimize - creates full pageplans

proc LogErr msg {
   LogReport ECCIS_ERROR ECCIC_APPL $msg
}


proc LogMsg msg {
   LogReport ECCIS_NOTICE ECCIC_APPL $msg
}


proc LogDebug msg {
   global DEBUG

   if {$DEBUG} {
      LogReport ECCIS_NOTICE ECCIC_APPL $msg
   }
}


proc ReportError { ErrorMsg } {

   global errorCode
   global errorInfo
   global THIS_SCRIPT
   global ErrProduct

   LogErr "ErrorMsg $ErrorMsg"
   LogErr "ErrorNumber $errorCode"
   LogErr "ErrorInfo $errorInfo"

   set TmpDir [pwd]
   set mode w
   if [file exists $TmpDir/[pid].status] {
      set mode a
   }
   if [catch { set fp [open $TmpDir/[pid].status $mode] }] {
      LogErr "Cannot open status file"
   } else {
      puts $fp "#############################################################"
      puts $fp $errorCode
      puts $fp $errorInfo
      puts $fp $ErrorMsg
      puts $fp "#############################################################"
      catch [close $fp]
   }

   ## RM 10DEC2012 ReportPlanError is not part of the standard functionality.
   ## if [clength $ErrProduct]  {
   ##    ReportPlanError $ErrProduct $errorInfo $ErrorMsg
   ## } else {
   ##    ReportPlanError "Default" $errorInfo $ErrorMsg
   ## }

   if [catch {ConfigGetValue Integration.PPI-PlanPag.Hooks(ImportError)} HookErr] {
      set HookErr ""
   }
   if [clength $HookErr] {
      # Call ErrHook with no params (old way)
      if [catch {set HookResult [uplevel $HookErr]} HookError] {
         LogMsg "Hookfunction $HookErr failed - $HookError"
      }
   }
   set THIS_SCRIPT PPI-PlanPagXML
}


###############################################################################
# Return names of all colours in Parent Node
# Used for both page and placement(ads) nodes
#
proc GetColorNames {Parent} {
   if {[catch {DOM -var Colours getelementsbytagname $Parent Colours}]} {
      return ""
   }

   set value {}

   foreach c $Colours {
      foreach Node [DOM getchildnodes $c] {
         set NodeType [DOM getnodetype $Node]
         set NodeName [DOM getnodename $Node]
         if {[cequal $NodeType "TEXT_NODE"]} {
            catch {lappend value [DOM getnodevalue $Node]}
         }
      }
   }

   return $value
}


###############################################################################
# Return cmyk, spot1, spot2, spot3 for Parent Node
# Used for both page and placement(ads) nodes
# PPI colors are converted into CCI colors using ConfigBase SpotColors
#
proc GetColors {Parent CMYK Spot1 Spot2 Spot3} {
   upvar $CMYK cmyk \
         $Spot1 spot1 \
         $Spot2 spot2 \
         $Spot3 spot3

   global ColourList

   set cmyk "000K"; set spot1 ""; set spot2 ""; set spot3 ""

   set cyan 0; set magenta 0; set yellow 0; set black 0
   set colnames [GetColorNames $Parent]
   set spotcolors {}
   set spotfound 0
   foreach c $colnames {
      if [cequal $ColourList($c,Type) "0"] {
         set spotnum $ColourList($c,CCIColor)
         if {[ctype digit $spotnum] && $spotfound < 3} { 
            incr spotfound
            set spot$spotfound $spotnum
         }
      } else {
         if [regexp -nocase {c} $ColourList($c,Type)] {set cyan "C"; continue }
         if [regexp -nocase {m} $ColourList($c,Type)] {set magenta "M"; continue }
         if [regexp -nocase {y} $ColourList($c,Type)] {set yellow "Y"; continue }
         if [regexp -nocase {k} $ColourList($c,Type)] {set black "K"; continue }
      }
   }
   set cmyk $cyan$magenta$yellow$black

}


proc CreateSubNode { rootNode nodeName nodeValue } {
   set node [DOM createElement $rootNode $nodeName]
   set textNode [DOM createTextNode $rootNode $nodeValue]
   DOM appendChild $node $textNode
   DOM appendChild $rootNode $node
}


###############################################################################
#  AD line format:
#
#  "AD:"<TAB>
#  1 <BOOKING_NUMBER><TAB>
#  2 <DESCRIPTION><TAB>
#  3 <AD_RELATED_INFO><TAB>
#  4 <FIRST_PUB_DATE><TAB>
#  5 <LAST_PUB_DATE><TAB>
#  6 <CUSTOMER><TAB>
#  7 <AD_COLOR><TAB>
#  8 <AD_WIDTH><TAB>
#  9 <AD_HEIGHT><TAB>
# 10 <MAT_TYPE><TAB>
# 11 <AD_TYPE><TAB>
# 12 <AD_POS><NL>

# KK Description
proc MakeOneAdXML { AdNode AdName CustomerName Description AdRelatedInfo PubDate LastPubDate PosX PosY AdType\
                 Object FileFormat FixedPosition Zone Edition} {
   upvar $AdNode adNode
   upvar $Object obj

   GetColors $obj cmyk spot1 spot2 spot3
   set Color $cmyk
   if {[clength $spot1]} { append Color ", $spot1" }
   if {[clength $spot2]} { append Color ", $spot2" }
   if {[clength $spot3]} { append Color ", $spot3" }
   
   set Height [DOM getattribute $obj Height]
   set Width [DOM getattribute $obj Width]
   set Height [expr $Height / 1000.0]
   set Width [expr $Width / 1000.0]
   set PosX [expr $PosX / 1000.0]
   set PosY [expr $PosY / 1000.0]

   ## RM 01MAR2011 Create an ad node.
   CreateSubNode $adNode "BookingNumber" "$AdName"
# KK Description
   # Remove commas in Description. 
   regsub -all "," $Description "." Description
   CreateSubNode $adNode "Description" "$Description"
   CreateSubNode $adNode "AdRelatedInfo" "$AdRelatedInfo"
   CreateSubNode $adNode "FirstPubDate" "$PubDate"
   CreateSubNode $adNode "LastPubDate" "$LastPubDate"
   # Remove commas in CustomerName. Packed into MessageFields with other
   # fields separated with comma, therefore it cannot contain commas
   regsub -all "," $CustomerName "." CustomerName
   CreateSubNode $adNode "Customer" "$CustomerName"
   CreateSubNode $adNode "AdColor" "$Color"
   CreateSubNode $adNode "AdWidth" "$Width"
   CreateSubNode $adNode "AdHeight" "$Height"
   CreateSubNode $adNode "MatType" "EPS"
   CreateSubNode $adNode "AdType" "$AdType"
   set adPosNode [DOM createElement $adNode "AdPos"]
   CreateSubNode $adPosNode "XPos" "$PosX"
   CreateSubNode $adPosNode "YPos" "$PosY"
   DOM appendChild $adNode $adPosNode

   # See if there are InsertionID's for AD_PRODUCTION_INFO
   set adproductioninfo ""
   set insertions [DOM getelementsbytagname $obj Insertions]
   if {![catch {set insertions [DOM getelementsbytagname $obj Insertions]}]} {
      if {![catch {set insertionlist [DOM getelementsbytagname $insertions Insertion]}]} {
         foreach insertion $insertionlist {
            if [catch {set TEC [DOM getattribute $insertion TEC]}] {
               set TEC $Zone
            }
            if [catch {set PrProdTyp [DOM getattribute $insertion PrProdTyp]}] {
               set PrProdTyp $Edition
            }
            if {$TEC == $Zone && $PrProdTyp == $Edition} {
               if [clength $adproductioninfo] { 
                  set adproductioninfo "${adproductioninfo}#"
               }
               set adproductioninfo "${adproductioninfo}[DOM getattribute $insertion InsertionId]"
            }
         }
      }
   }
   CreateSubNode $adNode "AdProdInfo" "$adproductioninfo"
   CreateSubNode $adNode "AdGuaranteedPos" "$FixedPosition"
   CreateSubNode $adNode "AdNotUsed3" ""
   CreateSubNode $adNode "AdCust1" ""
   CreateSubNode $adNode "AdCust2" ""
   CreateSubNode $adNode "AdCust3" ""
}


proc GetSpreadValue { product index section secpageno page PageId} {
   #
   # Return values 0 - Not a spread
   #               1 - Spread with consecutive pages
   #               2 - Hidden spread
   upvar $page Page
   upvar $product Product

   global errorInfo errorCode
   
   if {![DOM getattribute $Page($PageId,DOM) Panoramic]} {
      # Not a spread page
      return 0
   }
   set Special [DOM getattribute $Page($PageId,DOM) Special]
   set Left 0
   if {[cequal $Special "L"] || [cequal $Special "l"]} {
      # Page is a left
      set Left 1
   }
   # Find info on spread partner
   set Key [DOM getelementsbytagname $Page($PageId,DOM) PanoPageKey]
   set SpreadId [DOM getattribute $Key Id]
   set SpreadOrderNo [DOM getattribute $Key OrderNo]
   set PagePlcms $Product($index,PagePlcms)
   set spreadpageno 0
   # Lookup spread partner in page placements
   foreach p $PagePlcms {
      set Key [DOM getelementsbytagname $p PageKey]
      set Id [DOM getattribute $Key Id]
      set OrderNo [DOM getattribute $Key OrderNo]
      if {[info exist Page($Id)]} {
         if {[cequal $Id $SpreadId] && [cequal $OrderNo $SpreadOrderNo]} {
            set spreadid $SpreadId
            if [catch {set spreadsection [DOM getattribute $p RSSection]}] {
               set spreadpageno [DOM getattribute $p RelPageNo]
               set spreadsection [DOM getattribute $p SectionNo]

               ## RM 16JAN2014 Next line no longer needed.
               ## set spreadsection $Page($SpreadId,Section)
            } else {
               set spreadpageno [DOM getattribute $p RSPageNo]
            }
            break
         }
      }
   }
   if {!$spreadpageno} {
      ## RM 30SEP2011 Call to ReportError inserted.
      # Unable to find spread partner - Report error
      set errorCode 57
      set errorInfo [TransMsg -f PlanProcessingMailMessages.txt -n PLANPAGXML_NO_SPREAD_PARTNER_ERRORINFO -d "Could not find spread partner."]
      set ErrMsg [TransMsg -f PlanProcessingMailMessages.txt -n PLANPAGXML_NO_SPREAD_PARTNER_ERRORMSG -d "Cannot find spread partner for PageId %s" $PageId]
      ReportError $ErrMsg
      error "Cannot find spread partner for PageId $PageId" \
            "Cannot find spread partner for PageId $PageId" 57
   }
   if {[cequal $section $spreadsection]} {
      if {$Left} {
         if {[expr $secpageno + 1] == $spreadpageno} {
            set spreadval 1
         } else {
            set spreadval 2
         }
      } else {
         if {[expr $spreadpageno + 1] == $secpageno} {
            set spreadval 1
         } else {
            set spreadval 2
         }
      }
      return $spreadval
   }
   return 0
}


proc FindEditorialPartPages {Page PartPage PageId EdPartPageIds} {
   upvar $Page page
   upvar $PartPage partpage
   upvar $EdPartPageIds edpartpageids
   set edpartpageids [list]
   set PartPagePlcm [DOM getelementsbytagname $page($PageId,DOM) PartPagePlcm]
   foreach p $PartPagePlcm {
      set Key [DOM getelementsbytagname $p PartPageKey]
      set PartPageId [DOM getattribute $Key Id]
      if ![info exists partpage($PartPageId,DOM)] {
         continue
      }
      set pp $partpage($PartPageId,DOM)
      foreach AttributeName [list EdPart CombinerEdPart EdPartLongName] {
         if [catch {
            set EditorialIndicator [DOM getattribute $pp $AttributeName]
         }] { continue }
         if [cequal $EditorialIndicator " "] { continue }
         if [cequal $EditorialIndicator ""] { continue }
         lappend edpartpageids $PartPageId
         break
      }
   }
}


###############################################################################
#  PAGE line format:
#
#"PAGE:"<TAB>
#  1 <PHYSICAL_BOOK><TAB>
#  2 <BOOK_PAGE_NUMBER><TAB>
#  3 <DESK><TAB>
#  4 <SUB_DESK><TAB>
#  5 <SPREAD><TAB>
#  6 <STATUS><TAB>
#  7 <DEADLINE><TAB>
#  8 <PAGE_PRINT_INFO><TAB>
#  9 <CMYK><TAB>
# 10 <SPOT1><TAB>
# 11 <SPOT2><TAB>
# 12 <SPOT3><TAB>
# 13 <CYAN_FILM><TAB>
# 14 <MAG_FILM><TAB>
# 15 <YEL_FILM><TAB>
# 16 <BLACK_FILM><TAB>
# 17 <SPOT1_FILM><TAB>
# 18 <SPOT2_FILM><TAB>
# 19 <SPOT3_FILM><TAB>
# 20 <PAGE_ID><TAB>
# 21 <TEMPLATE_PAGE><TAB>
# 22 <PROD_FORM><TAB>
# 23 <TEXT_SOURCE_DIR><TAB>
# 24 <TEXT_SOURCE_PAGE><TAB>
# 25 <RUNNING_PAGE><TAB>
# 26 <CMY_DEADLINE><TAB>
# 27 <COLOR_GRP><TAB>
# 28 <CUST_INT><TAB>
# 29 <CUST_CHAR><TAB>
# 30 <CUST_DATE><TAB>
# 31 <ACTIVE><NL>
#
proc MakeOnePageXML { PageNode Product index Page PagePlcm PartPage pagenum FileFormat Zone} {
   upvar $PageNode pageNode\
         $Page page\
         $PagePlcm pageplcm\
         $PartPage partpage \
         $Product product
   
   global NOTEMPLATES

   set PageId $pageplcm($pagenum,PageId)

   set spread [GetSpreadValue product $index $pageplcm($pagenum,Section) \
                              $pageplcm($pagenum,BookPageNo) page $PageId]

   # If RSAdRule is present (From PlanPag 2.9) use it
   if [catch {set adrules [DOM getattribute $page($PageId,DOM) RSAdRule]}] {
      set adrules $product($index,AdRules)
   }
   set orderno $page($PageId,OrderNo)

## HL -  Start of Logical Page Name Handling
   set PartPagePlcm [DOM getelementsbytagname $page($PageId,DOM) PartPagePlcm]
   foreach p $PartPagePlcm {
      set Key [DOM getelementsbytagname $p PartPageKey]
      set id [DOM getattribute $Key Id]
      if ![info exists partpage($id,DOM)] {
         continue
      }
      set PartPageId $id
      foreach pl $partpage($PartPageId,Placements) {
         set ElementType [DOM getattribute $pl ElementType]
         if {[cequal $ElementType "B"] || [cequal $ElementType "U"]} {
         set MyNameIs [DOM getattribute $pl Comment]
         LogMsg "My Name is $MyNameIs"
}
}
}
   if [catch {set ccipagename $MyNameIs}] {
      set ccipagename ""
            LogMsg "ccipagename is $ccipagename"
   }
  if [cequal "" $ccipagename] {
#HWN
# Setup NYT page name
   set partPagePlcm [DOM getelementsbytagname $page($PageId,DOM) PartPagePlcm]
   set ppKey [DOM getelementsbytagname $partPagePlcm PartPageKey]
   set ppId [DOM getattribute $ppKey Id]
   set curPartPage $partpage($ppId,DOM)
   set edPart [DOM getattribute $curPartPage EdPart]
# HL - If PPI attribute for EdPart is empty, set it to TMP
   if [cequal "" $edPart] {
      set edPart TMP
         }
   set ccipagename [format "%.3s%02d" $edPart $pagenum]
   LogDebug "PageId $PageId is named: $ccipagename"
   # Check if Comment is empty - if so store CCI name for future reference
   if ![catch {set tmpname [DOM getattribute $page($PageId,DOM) Comment]}] {
      if [cequal [string trim $tmpname] ""] {
         DOM setattribute $page($PageId,DOM) Comment CCI:$ccipagename
      }
   }
   if {[info exists page($PageId,CCIName)] && [cequal $page($PageId,CCIName) ""]} {
     # If a page is common we only store the name first time - 
     #   the page may have different names i different zones because of added
     #   pages
      set page($PageId,CCIName) $ccipagename
#   }
   } else {
      if [cequal "CCI:" [csubstr $ccipagename 0 4]] {
         set ccipagename [csubstr $ccipagename 4 end]
 #     } else {
 #        set ccipagename ""
            LogMsg "ccipagename is $ccipagename"
   }
   }

      set ppipagename $ccipagename
#   if [catch {set ppipagename [DOM getattribute $page($PageId,DOM) Name]}] {
#      set ppipagename ""
#  }
#   set ppipagename [string trim $ppipagename]
#   if {[clength $ppipagename] == 0} {
#
#      set ccipagename [format "%.4s%.1s_%02d" $product($index,Zone) \
#                                     $pageplcm($pagenum,Section) \
#                                     $pagenum]
#      LogDebug "PageId $PageId is named: $ccipagename"
#     DOM setattribute $page($PageId,DOM) Comment CCI:$ccipagename
#   } else {
#      set ccipagename $ppipagename
#   }
#   if {$spread} {
      #LogDebug "SpreadValue for $ccipagename: $spread"
#   }

## HL -  End of Logical Page Name Handling
   
   ## Page activation and sourcing
   set textsrcdir $page($PageId,SrcDir)
   set textsrcpage ""
   if [cequal "" $textsrcdir] {
      set active 1
      ## This PageId has not been used before, so it must be active, but
      ## should it source some page based on partpages?
      FindEditorialPartPages page partpage $PageId EdPartPageIds
      set page($PageId,EdPartPageIds) $EdPartPageIds
      set textsrcpage ""
      foreach EdPartPageId $EdPartPageIds {
         set SourcePageId $partpage($EdPartPageId,FirstPageId)
         if [cequal "" $SourcePageId] {
            continue
         }
         ## Accept pages as source, if they have the same section and page no
         if {$page($SourcePageId,SrcPageNo) == $pageplcm($pagenum,BookPageNo) && \
              [cequal $page($SourcePageId,SrcSection) $pageplcm($pagenum,Section)]} {
            LogDebug "Page $page($PageId,CCIName) sourcing from $page($SourcePageId,CCIName) same section+page"
            set textsrcdir $page($SourcePageId,SrcDir)
            set textsrcpage $page($SourcePageId,CCIName)
            break
         }
         FindEditorialPartPages page partpage $SourcePageId SourceEdPartPageIds
         ## Accept if not same zone but same partpages
         if {$Zone != $page($SourcePageId,SrcDir) && \
             $EdPartPageIds == $SourceEdPartPageIds} {
            LogDebug "Page $page($PageId,CCIName) sourcing from $page($SourcePageId,CCIName) not same position"
            set textsrcdir $page($SourcePageId,SrcDir)
            set textsrcpage $page($SourcePageId,CCIName)
            break
         }
      }

      ## RM 23MAY2011 The CCI name of the first occurrence of this PPI PageId
      ## needs to be stored for future sourcing.
      set page($PageId,SrcPage) $ccipagename
   } else {
      ## We are sourcing an identical page - make inactive
      set active 0

      ## RM 23MAY2011 I think the following line is an error.
      ## set textsrcpage $ccipagename
      set textsrcpage $page($PageId,SrcPage)

   }

   set proddate [DOM getattribute $page($PageId,DOM) PageProdDate]
   if {$proddate == 0} {
      set deadline $product($index,Deadline)
      if {[scan $product($index,PubDate) "%2d%2d%2d" d m y] != 3} {
         LogErr "PubDate is not legal"
      } else {
         set proddate "[fmtclock [cvtclock "$d $m $y" "%d %m %y"] \%Y\%m\%d]"
      }
   } else {
      if {[scan $proddate "%4d%2d%2d" Y m d] != 3} {
         LogErr "proddate is not legal"
      } else {
         set deadline "[fmtclock [cvtclock "$Y $m $d" "%Y %m %d"] \%d\%m\%y]0000"
      }
   }
   set prodtime [DOM getattribute $page($PageId,DOM) PageProdTime]
   if {[clength $prodtime] == 5} {
      set prodtime "0${prodtime}"
   }
   if {$prodtime != 0} {
      if {[scan $proddate$prodtime "%4d%2d%2d%2d%2d%2d" Y m d H M S] != 6 } {
         LogErr "proddate+prodtime is not legal"
      } else {
         set deadline [fmtclock [cvtclock "$Y $m $d $H $M $S" "%Y %m %d %H %M %S"] \%d\%m\%y\%H\%M]
      }
   }

   # If ColorDeadline fields are present (From PlanPag 2.9) use them
   if [catch {set coldeadlinedate [DOM getattribute $page($PageId,DOM) ColourDeadlineDate]}] {
      set coldeadline ""
   } else {
      if {$coldeadlinedate <= 0} {
         set coldeadline ""
      } else {
         if {[scan $coldeadlinedate "%4d%2d%2d" Y m d] != 3} {
            LogErr "ColourDeadlineDate is not legal"
         } else {
            set coldeadline "[fmtclock [cvtclock "$Y $m $d" "%Y %m %d"] \%d\%m\%y]0000"
            set coldeadlinetime [DOM getattribute $page($PageId,DOM) ColourDeadlineTime]
            if {$coldeadlinetime != 0} {
               if {[scan $coldeadlinedate$coldeadlinetime "%4d%2d%2d%2d%2d%2d" \
                                                           Y m d H M S] != 6 } {
                  LogErr "ColourDeadlineTime is not legal"
               } else {
                  set coldeadline [fmtclock [cvtclock "$Y $m $d $H $M $S" "%Y %m %d %H %M %S "] \%d\%m\%y\%H\%M]
               }
            }
         }
      }
   }

   GetColors $page($PageId,DOM) cmyk spot1 spot2 spot3

   set PartPageId ""
   set PartPagePlcm [DOM getelementsbytagname $page($PageId,DOM) PartPagePlcm]
   foreach p $PartPagePlcm {
      set Key [DOM getelementsbytagname $p PartPageKey]
      set id [DOM getattribute $Key Id]
      if ![info exists partpage($id,DOM)] {
         continue
      }
      set PartPageId $id
      set pp $partpage($id,DOM)
      if [catch {set EdPart [DOM getattribute $pp EdPartLongName]}] { 
         set EdPart "" 
      }
      set EdPart [string trim $EdPart]
      if [clength $EdPart] {
         set desk $EdPart
         set EdPP $pp
         break
      }
      if [catch {set EdPart [DOM getattribute $pp EdPart]}] { set EdPart "" }
      set EdPart [string trim $EdPart]
      if [clength $EdPart] {
         set desk $EdPart
         set EdPP $pp
         break
      }
      if [catch {set CombinerEdPart [DOM getattribute $pp CombinerEdPartLongName]}] { 
         set CombinerEdPart "" 
      }
      set CombinerEdPart [string trim $CombinerEdPart]
      if [clength $CombinerEdPart] { 
         set desk $CombinerEdPart
         set EdPP $pp
         break
      } 
    
      if [catch {set CombinerEdPart [DOM getattribute $pp CombinerEdPart]}] { 
         set CombinerEdPart "" 
      }
      set CombinerEdPart [string trim $CombinerEdPart]
      if [clength $CombinerEdPart] { 
         set desk $CombinerEdPart
         set EdPP $pp
      } 
   }
   
   if {![info exists desk]} { 
      set desk $product($index,Desk)
   }

   if [catch {set contentTemplate [DOM getattribute $page($PageId,DOM) RSContentTemplateLongName]}] {
      # Get templates from old fields (until 2.8)
      if {![info exists desk]} {
         set contentTemplate $product($index,Template)
      } else {
         if [catch {set contentTemplate [DOM getattribute $EdPP LocationLongName]}] {
            set contentTemplate $product($index,Template)
         }
         set contentTemplate [string trim $contentTemplate]
         if {[clength $contentTemplate] == 0} {
            if [catch {set contentTemplate [DOM getattribute $EdPP Location]}] {
               set contentTemplate $product($index,Template)
            }
         }
         set contentTemplate [string trim $contentTemplate]
         set layoutTemplate {}
         if {$product($index,UseLayoutTemplates)} {
            if {![catch {set layoutTemplate [DOM getattribute $EdPP LayoutTypeName]}]} {
               set layoutTemplate [string trim $layoutTemplate]
            }
         }
      }
   } else {
      # Using RS fields (From 2.9)
      set contentTemplate [string trim $contentTemplate]
      if {[clength $contentTemplate] == 0} {
         set contentTemplate [DOM getattribute $page($PageId,DOM) RSContentTemplate]
         set contentTemplate [string trim $contentTemplate]
      }
      if {[clength $contentTemplate] == 0} { 
         set contentTemplate $product($index,Template)
      }
      if {$product($index,UseLayoutTemplates)} {
         set layoutTemplate [DOM getattribute $page($PageId,DOM) RSLayoutTemplateLongName]
         set layoutTemplate [string trim $layoutTemplate]
         if {[clength $layoutTemplate] == 0} {
            set layoutTemplate [DOM getattribute $page($PageId,DOM) RSLayoutTemplate]
            set layoutTemplate [string trim $layoutTemplate]
         }
      }
   }

   set CCISection $pageplcm($pagenum,Section)
   if {!$product($index,SectionNumeric) && [ctype digit $CCISection]} {
      # If section is numeric - convert to alphabetic
      set CCISection [ctype char [expr $CCISection + 64]]
   }
   if {$product($index,SectionNumeric) && [ctype alpha $CCISection]} {
      # If section is alphanumeric - convert to numeric
      set CCISection [expr [ctype ord $CCISection] - 64]
   }

   if [cequal [DOM getattribute $page($PageId,DOM) State] "V"] {
      set state 0
   } else {
      set state 1
   }
   set dumpversion [DOM getattribute $page($PageId,DOM) DumpVersion]

   ## RM 01MAR2011 Create a page node.
   CreateSubNode $pageNode "PhysicalBook" "$CCISection"
   CreateSubNode $pageNode "BookPageNumber" "$pageplcm($pagenum,BookPageNo)"
   CreateSubNode $pageNode "Desk" "$desk"
   CreateSubNode $pageNode "SubDesk" ""
   CreateSubNode $pageNode "SpreadPage" "$spread"
   CreateSubNode $pageNode "Status" ""
   CreateSubNode $pageNode "Deadline" "$deadline"
   CreateSubNode $pageNode "PagePrintInfo" "$PageId,$ppipagename,$pagenum,$state,$orderno,$dumpversion,$spread"
   CreateSubNode $pageNode "Cmyk" "$cmyk"
   CreateSubNode $pageNode "Spot1" "$spot1"
   CreateSubNode $pageNode "Spot2" "$spot2"
   CreateSubNode $pageNode "Spot3" "$spot3"
   CreateSubNode $pageNode "CyanFilm" ""
   CreateSubNode $pageNode "MagFilm" ""
   CreateSubNode $pageNode "YelFilm" ""
   CreateSubNode $pageNode "BlackFilm" ""
   CreateSubNode $pageNode "Spot1Film" ""
   CreateSubNode $pageNode "Spot2Film" ""
   CreateSubNode $pageNode "Spot3Film" ""
   CreateSubNode $pageNode "PageId" "$ccipagename"
   if {$NOTEMPLATES} {
      set contentTemplate ""
      set layoutTemplate ""
   }
   set templatePageNode [DOM createElement $pageNode "TemplatePage"]
   CreateSubNode $templatePageNode "Content" "$contentTemplate"
   CreateSubNode $templatePageNode "Layout" "$layoutTemplate"
   DOM appendChild $pageNode $templatePageNode
   CreateSubNode $pageNode "ProdForm" "$pageplcm($pagenum,Form)"
   CreateSubNode $pageNode "TextSourceDir" "$textsrcdir"
   CreateSubNode $pageNode "TextSourcePage" "$textsrcpage"
   CreateSubNode $pageNode "RunningPage" "$pagenum"
   CreateSubNode $pageNode "CmyDeadline" "$coldeadline"
   CreateSubNode $pageNode "ColorGrp" ""
   CreateSubNode $pageNode "AdRules" "$adrules"
   CreateSubNode $pageNode "CustChar" ""
   CreateSubNode $pageNode "CustDate" ""
   CreateSubNode $pageNode "Active" "$active"
   CreateSubNode $pageNode "NoMaster" ""
   CreateSubNode $pageNode "Cust2" ""
   CreateSubNode $pageNode "PageType" ""
   CreateSubNode $pageNode "Cust4" ""
   CreateSubNode $pageNode "Cust5" ""
   CreateSubNode $pageNode "Cust6" ""
   CreateSubNode $pageNode "Cust7" ""
   CreateSubNode $pageNode "Cust8" ""
   CreateSubNode $pageNode "Cust9" ""
   CreateSubNode $pageNode "Cust10" ""
   CreateSubNode $pageNode "Desk2" ""
   CreateSubNode $pageNode "Desk2NewsHole" "0"
   CreateSubNode $pageNode "Desk2Placement" "0"
   CreateSubNode $pageNode "NotUsed1" ""
   CreateSubNode $pageNode "NotUsed2" ""
   CreateSubNode $pageNode "NotUsed3" ""

   # Make adlines for the page
   foreach p $PartPagePlcm {
      set Key [DOM getelementsbytagname $p PartPageKey]
      set PartPageId [DOM getattribute $Key Id]
      set PartPageOrderNo [DOM getattribute $Key OrderNo]
      set OffsetX [DOM getattribute $p PosX]
      set OffsetY [DOM getattribute $p PosY]
      if ![info exists partpage($PartPageId,DOM)] {
         continue
      }
      set pp $partpage($PartPageId,DOM)
      set MakeUpFlag [DOM getattribute $pp MakeUpFlag]
      set ExternProduced [DOM getattribute $pp ExternProduced]
      if {$product($index,MakeClassAd)} {
         if {$MakeUpFlag == 1 || $ExternProduced == 1} {
            # Make a Classified Ad Block / External produced block
            if {$MakeUpFlag == 1} {
               set Comment [DOM getattribute $pp Comment]
               if {[clength $Comment] && ![cequal " " $Comment]} {
                  set Name $Comment
               } else {
                  set Name ${PartPageId}_$PartPageOrderNo
               }
            } else {
               set Name [DOM getattribute $pp FileName]
            }
            if {[clength $Name] && ![cequal " " $Name]} {
               set adNode [DOM createElement $pageNode "Ad"]
# KK Description
               MakeOneAdXML adNode $Name {} {} $PartPageId $product($index,PubDate) \
                         $product($index,LastPublDate) $OffsetX $OffsetY 2 pp \
                         $FileFormat 1 \
                         $product($index,Zone) $product($index,Edition)
               DOM appendChild $pageNode $adNode
            }
            if {$product($index,IgnoreAdsInClass)} {
               continue
            }
         }
      }
      set OldName ""
      foreach pl $partpage($PartPageId,Placements) {
         set ElementType [DOM getattribute $pl ElementType]
         if {[cequal $ElementType "B"] || [cequal $ElementType "U"]} {
            # Ignore Blockades they have no name
            continue
         }
         set Name [DOM getattribute $pl AdSystemNo]
         set Cust [DOM getattribute $pl CustomerName]
# KK: Description
         set Description [DOM getattribute $pl AdComment]
         set FixedPosition [DOM getattribute $pl FixedFlag]
         set PosX [DOM getattribute $pl PosX]
         set PosY [DOM getattribute $pl PosY]
         set PosX [expr $PosX + $OffsetX]
         set PosY [expr $PosY + $OffsetY]
         if {$spread} {
            if {$pageplcm($pagenum,BookPageNo) % 2} {
               if {$PosX < 0} {
                  # Right spread page - ad is placed on left page also - ignore
                  LogDebug "Ad $Name ignored on right spread page $ccipagename"
                  continue
               }
            } else {
               # Left spread page - find out if ad is really on right page
               set OnRightPage 0
               set Key [DOM getelementsbytagname $page($PageId,DOM) PanoPageKey]
               set SpreadPageId [DOM getattribute $Key Id]
               set SpreadPartPagePlcm [DOM getelementsbytagname $page($SpreadPageId,DOM) PartPagePlcm]
               foreach ppp $SpreadPartPagePlcm {
                  set Key [DOM getelementsbytagname $ppp PartPageKey]
                  if [cequal $PartPageId [DOM getattribute $Key Id]] {
                     if {[expr $PosX + [DOM getattribute $ppp PosX]] > 0} {
                        set OnRightPage 1
                        break
                     }
                  }
               }
               if {$OnRightPage} {
                  # Left spread page - ad is placed on right page also - ignore
                  LogDebug "Ad $Name ignored on left spread page $ccipagename"
                  continue
               }
            }
         }
         set LastPublDate $product($index,LastPublDate)
         if {![catch {set DueDate [DOM getattribute $pl AdFileDueDate]}]} {
            if {[scan $DueDate "%4d%2d%2d" Y m d] == 3} {
               # Make sure date is not later than max unix date - Trier
               if {$Y > 2030} {
                  set Y 2030
               }
               set DueDate [fmtclock \
                   [expr [cvtclock "$Y $m $d" "%Y %m %d"] + \
                    (86400 * $product($index,PublDateoffset))] "\%d\%m\%y"]
               scan $DueDate "%2d%2d%2d" dd dm dy
               scan $LastPublDate "%2d%2d%2d" ld lm ly
               # Make sure AdFileDueDate is later 
               if {[cvtclock "$ld $lm $ly" "%d %m %y"] <= \
                   [cvtclock "$dd $dm $dy" "%d %m %y"]} {
                  set LastPublDate $DueDate
               } else {
                  LogMsg "Not using AdFileDueDate $DueDate for $Name"
               }
            }
         }
         set adNode [DOM createElement $pageNode "Ad"]
# KK Description
         MakeOneAdXML adNode $Name $Cust $Description {} \
                   $product($index,PubDate) \
                   $LastPublDate $PosX $PosY $ElementType \
                   pl $FileFormat $FixedPosition \
                   $product($index,Zone) $product($index,Edition)
         DOM appendChild $pageNode $adNode
         set OldName $Name
      }
   }
}


proc DecodePrintInfo { PrintInfo BestPractice PageId PageName PageNo State OrderNo DumpVersion Spread} {
   upvar $BestPractice bestpractice
   upvar $PageId pageid
   upvar $PageName pagename
   upvar $PageNo pageno
   upvar $State state
   upvar $OrderNo orderno
   upvar $DumpVersion dumpversion
   upvar $Spread spread

   set tokens [split $PrintInfo "#"]
   if {[llength $tokens] == 17} {
      set bestpractice [join [lrange $tokens 0 15] "#"]
      set extPrintInfo [lindex $tokens 16]
   } else {
       set ppitoken [expr [llength $tokens] - 1]
       if {$ppitoken > 0} {
          set bestpractice [join [lrange $tokens 0 [expr $ppitoken -1]] "#"]
          set extPrintInfo [lindex $tokens $ppitoken]
       } else {
          set bestpractice {}
          set extPrintInfo $PrintInfo
       }
   }
   set tokens [split $extPrintInfo ,]
   set pageid [lindex $tokens 0]
   set pagename [lindex $tokens 1]
   set pageno [lindex $tokens 2]
   set state [lindex $tokens 3]
   set orderno [lindex $tokens 4]
   if {[llength $tokens] > 5} {
      set dumpversion [lindex $tokens 5]
   } else {
      set dumpversion {}
   }
   if {[llength $tokens] > 6} {
      set spread [lindex $tokens 6]
   } else {
      set spread 0
   }
}


proc EncodePrintInfo { BestPractice PageId PageName PageNo State OrderNo DumpVersion Spread} {
   if {[clength $BestPractice]} {
      set PrintInfo "${BestPractice}#${PageId},${PageName},${PageNo},${State},${OrderNo},${DumpVersion},${Spread}"
   } else {
      set PrintInfo "${PageId},${PageName},${PageNo},${State},${OrderNo},${DumpVersion},${Spread}"
   }
   return $PrintInfo
}


proc PutTextInNode {domNode strTxt} {
    if [cequal [DOM getnodetype $domNode] "TEXT_NODE"] {
      DOM setnodevalue $domNode $strTxt
    } else {
      set txtNodes [DOM getchildnodes $domNode]
      if {[llength $txtNodes]>1} { 
         error "Node ([DOM getnodename $domNode] [DOM getnodename $domNode]) contained more than one textnode. Unable to set nodevalue"
      } elseif {[llength $txtNodes] < 1} {
         set txtNode [DOM createTextNode $domNode $strTxt]
         DOM appendChild $domNode $txtNode 
      } else {
         set txtNode [lindex $txtNodes 0]
         if [cequal [DOM getnodetype $txtNode] "TEXT_NODE"] {
            DOM setnodevalue $txtNode $strTxt
         } else {
            error "Node ([DOM getnodename $domNode]) contained no textnode."
         }
      }
   }
}


proc GetNodeValue { dom nodename } {
   set node [DOM getelementsbytagname $dom $nodename]
   if { [llength $node] > 1 } {
      error "Unable to read node value. Node ($nodename) is not unique in selected DOM."
   }
   if [catch {
      set value [DOM getnodevalue [DOM getfirstchild $node]]
   } msg] {
      set value ""
   }
   return $value
}


###############################################################################
# We have spreads defined on CCI. They are merged into new plan
# check if they are still valid after this update
# Both CCI spread pages must be present
# They must both be CCI spreads only (not spread on PPI)
# The spread must be a legal spread - mate must be same as before
proc ValidateCCISpreadsXML { PlanDOM Pageplcms } {

   upvar $PlanDOM planDOM
   upvar $Pageplcms pageplcms

   global TransStatus
   global WSM_RES
   set i 0
   set spreadsremoved 0
   set Variant [GetNodeValue $planDOM NewsPaper]
   GetPlannerVar 10 $Variant CCIProduct 

   GetPlannerVar 220 $Variant dateformat
   scan [GetNodeValue $planDOM Date] "%2d%2d%2d" d m y
   set CCIDate [fmtclock [cvtclock "$d $m $y" "%d %m %y"] $dateformat]

   set CCIZone [GetNodeValue $planDOM Zone]
   set CCIEdition [GetNodeValue $planDOM Edition]

   foreach pageNode [DOM getelementsbytagname $planDOM Page] {
      set spread [GetNodeValue $pageNode SpreadPage]
      if {!$spread} { continue }
      if {!$spread} { continue }
      DecodePrintInfo [GetNodeValue $pageNode PagePrintInfo] extBestP \
                      extPageId extPageName extPageNo extState \
                      extOrderNo extDumpVer extSpread
      if {$extSpread} { continue }
      # We have found a CCI spread
      set sect [GetNodeValue $pageNode PhysicalBook]
      set sectpno [GetNodeValue $pageNode BookPageNumber]
      set pno [GetNodeValue $pageNode RunningPage]
      set pageId [GetNodeValue $pageNode PageId]
      set pagesinsect $pageplcms($pno,PagesInSect)
      if {$spread == 1} {
         # Visible spread
         if {$sectpno % 2} {
            if {$sectpno == 1} {
               set sprsectpno $pagesinsect
            } else {
               set sprsectpno [expr $sectpno - 1]
            }
         } else {
            if {$sectpno == $pagesinsect} {
               set sprsectpno 1
            } else {
               set sprsectpno [expr $sectpno + 1]
            }
         }
      } elseif {$spread == 2} {
         # Hidden spread
         set sprsectpno [expr $pagesinsect - $sectpno + 1]
      }

      # Find mate
      set legal 0
      foreach secondParsePageNode [DOM getelementsbytagname $planDOM Page] {
         set sprsect [GetNodeValue $secondParsePageNode PhysicalBook]
         set spreadPageId [GetNodeValue $secondParsePageNode PageId]
         if {$sprsect != $sect} { continue }
         if {$sprsectpno != [GetNodeValue $secondParsePageNode BookPageNumber]} { continue }
         set sprspread [GetNodeValue $secondParsePageNode SpreadPage]
         if {$sprspread != $spread} { continue }
         DecodePrintInfo [GetNodeValue $secondParsePageNode PagePrintInfo] \
                         extBestP extPageId extPageName extPageNo extState \
                         extOrderNo extDumpVer extSpread
         if {$extSpread} { continue }
         # Spread type and position is ok, but make sure same page
         set Space " "
         set sprsect [GetNodeValue $secondParsePageNode PhysicalBook]
         TransWsm DisTrans ex -one 113=P 103=$CCIProduct 105=$CCIDate \
                                   107=$CCIZone 109=$CCIEdition \
                                   111=$pageId 121=$Space \
                                   101=$CCIProduct 104=$CCIDate \
                                   106=$CCIZone 108=$CCIEdition \
                                   110=$pageId 118=$Space \
                                   16=11 2=$pageId 64:
         if {$TransStatus != 0} { 
            error "Unable to extract spread for $CCIProduct $CCIDate $CCIZone $CCIEdition $pageId" "Unable to extract spread for $CCIProduct $CCIDate $CCIZone $CCIEdition $pageId" 477
         }
         if {[lindex $WSM_RES 1] != $spreadPageId} { continue }
         set legal 1
         LogMsg "Mate found for $pageId -> $spreadPageId"
         break
      }
      if {!$legal} {
         set spreadNode [DOM getelementsbytagname $pageNode SpreadPage]
         PutTextInNode $spreadNode "0"
         LogMsg "Remove CCI spread on $pageId"
         set spreadsremoved 1
      } else {
         LogMsg "Keep CCI spread on $pageId"
      }
   }
   return $spreadsremoved
}


###############################################################################
#  PAGE line format:
#
#"PAGE:"<TAB>
#  1 <PHYSICAL_BOOK><TAB>
#  2 <BOOK_PAGE_NUMBER><TAB>
#  3 <DESK><TAB>
#  4 <SUB_DESK><TAB>
#  5 <SPREAD><TAB>
#  6 <STATUS><TAB>
#  7 <DEADLINE><TAB>
#  8 <PAGE_PRINT_INFO><TAB>
#  9 <CMYK><TAB>
# 10 <SPOT1><TAB>
# 11 <SPOT2><TAB>
# 12 <SPOT3><TAB>
# 13 <CYAN_FILM><TAB>
# 14 <MAG_FILM><TAB>
# 15 <YEL_FILM><TAB>
# 16 <BLACK_FILM><TAB>
# 17 <SPOT1_FILM><TAB>
# 18 <SPOT2_FILM><TAB>
# 19 <SPOT3_FILM><TAB>
# 20 <PAGE_ID><TAB>
# 21 <TEMPLATE_PAGE><TAB>
# 22 <PROD_FORM><TAB>
# 23 <TEXT_SOURCE_DIR><TAB>
# 24 <TEXT_SOURCE_PAGE><TAB>
# 25 <RUNNING_PAGE><TAB>
# 26 <CMY_DEADLINE><TAB>
# 27 <COLOR_GRP><TAB>
# 28 <CUST_INT><TAB>
# 29 <CUST_CHAR><TAB>
# 30 <CUST_DATE><TAB>
# 31 <ACTIVE><NL>
#
## RM 20MAR2011 Create a page node from a page in the extracted CCI plan.
proc MakeOnePageXMLFromCCIPlannerPageLine {PageNode pageLine} {

   upvar PageNode pageNode

   CreateSubNode $pageNode "PhysicalBook" [lindex $pageLine 1]
   CreateSubNode $pageNode "BookPageNumber" [lindex $pageLine 2]
   CreateSubNode $pageNode "Desk" [lindex $pageLine 3]
   CreateSubNode $pageNode "SubDesk" [lindex $pageLine 4]
   CreateSubNode $pageNode "SpreadPage" [lindex $pageLine 5]
   CreateSubNode $pageNode "Status" [lindex $pageLine 6]
   CreateSubNode $pageNode "Deadline" [lindex $pageLine 7]
   CreateSubNode $pageNode "PagePrintInfo" [lindex $pageLine 8]
   CreateSubNode $pageNode "Cmyk" [lindex $pageLine 9]
   CreateSubNode $pageNode "Spot1" [lindex $pageLine 10]
   CreateSubNode $pageNode "Spot2" [lindex $pageLine 11]
   CreateSubNode $pageNode "Spot3" [lindex $pageLine 12]
   CreateSubNode $pageNode "CyanFilm" [lindex $pageLine 13]
   CreateSubNode $pageNode "MagFilm" [lindex $pageLine 14]
   CreateSubNode $pageNode "YelFilm" [lindex $pageLine 15]
   CreateSubNode $pageNode "BlackFilm" [lindex $pageLine 16]
   CreateSubNode $pageNode "Spot1Film" [lindex $pageLine 17]
   CreateSubNode $pageNode "Spot2Film" [lindex $pageLine 18]
   CreateSubNode $pageNode "Spot3Film" [lindex $pageLine 19]
   CreateSubNode $pageNode "PageId" [lindex $pageLine 20]
   set templatePageNode [DOM createElement $pageNode "TemplatePage"]
   set ccitemplates [split [lindex $pageLine 21] /]
   set contentTemplate [lindex $ccitemplates 0]
   set layoutTemplate [lindex $ccitemplates 1]
   CreateSubNode $templatePageNode "Content" "$contentTemplate"
   CreateSubNode $templatePageNode "Layout" "$layoutTemplate"
   DOM appendChild $pageNode $templatePageNode
   CreateSubNode $pageNode "ProdForm" [lindex $pageLine 22]
   CreateSubNode $pageNode "TextSourceDir" [lindex $pageLine 23]
   CreateSubNode $pageNode "TextSourcePage" [lindex $pageLine 24]
   CreateSubNode $pageNode "RunningPage" [lindex $pageLine 25]
   CreateSubNode $pageNode "CmyDeadline" [lindex $pageLine 26]
   CreateSubNode $pageNode "ColorGrp" [lindex $pageLine 27]
   CreateSubNode $pageNode "AdRules" [lindex $pageLine 28]
   CreateSubNode $pageNode "CustChar" [lindex $pageLine 29]
   CreateSubNode $pageNode "CustDate" [lindex $pageLine 30]
   CreateSubNode $pageNode "Active" [lindex $pageLine 31]
   CreateSubNode $pageNode "NoMaster" [lindex $pageLine 32]
   CreateSubNode $pageNode "Cust2" [lindex $pageLine 33]
   CreateSubNode $pageNode "PageType" [lindex $pageLine 34]
   CreateSubNode $pageNode "Cust4" [lindex $pageLine 35]
   CreateSubNode $pageNode "Cust5" [lindex $pageLine 36]
   CreateSubNode $pageNode "Cust6" [lindex $pageLine 37]
   CreateSubNode $pageNode "Cust7" [lindex $pageLine 38]
   CreateSubNode $pageNode "Cust8" [lindex $pageLine 39]
   CreateSubNode $pageNode "Cust9" [lindex $pageLine 40]
   CreateSubNode $pageNode "Cust10" [lindex $pageLine 41]
   CreateSubNode $pageNode "Desk2" [lindex $pageLine 42]
   CreateSubNode $pageNode "Desk2NewsHole" [lindex $pageLine 43]
   CreateSubNode $pageNode "Desk2Placement" [lindex $pageLine 44]
   CreateSubNode $pageNode "NotUsed1" [lindex $pageLine 45]
   CreateSubNode $pageNode "NotUsed2" [lindex $pageLine 46]
   CreateSubNode $pageNode "NotUsed3" [lindex $pageLine 47]
}


###############################################################################
#  AD line format:
#
#  "AD:"<TAB>
#  1 <BOOKING_NUMBER><TAB>
#  2 <DESCRIPTION><TAB>
#  3 <AD_RELATED_INFO><TAB>
#  4 <FIRST_PUB_DATE><TAB>
#  5 <LAST_PUB_DATE><TAB>
#  6 <CUSTOMER><TAB>
#  7 <AD_COLOR><TAB>
#  8 <AD_WIDTH><TAB>
#  9 <AD_HEIGHT><TAB>
# 10 <MAT_TYPE><TAB>
# 11 <AD_TYPE><TAB>
# 12 <AD_POS><NL>
## RM 16MAR2011 Create an ad node from an ad in the extracted CCI plan.
proc MakeOneAdXMLFromCCIPlannerAdLine {AdNode adLine} {

   upvar $AdNode adNode

   CreateSubNode $adNode "BookingNumber" [lindex $adLine 1]
   CreateSubNode $adNode "Description" [lindex $adLine 2]
   CreateSubNode $adNode "AdRelatedInfo" [lindex $adLine 3]
   CreateSubNode $adNode "FirstPubDate" [lindex $adLine 4]
   CreateSubNode $adNode "LastPubDate" [lindex $adLine 5]
   CreateSubNode $adNode "Customer" [lindex $adLine 6]
   CreateSubNode $adNode "AdColor" [lindex $adLine 7]
   CreateSubNode $adNode "AdWidth" [lindex $adLine 8]
   CreateSubNode $adNode "AdHeight" [lindex $adLine 9]
   CreateSubNode $adNode "MatType" [lindex $adLine 10]
   CreateSubNode $adNode "AdType" [lindex $adLine 11]
   set adPosNode [DOM createElement $adNode "AdPos"]
   CreateSubNode $adPosNode "XPos" [lindex $adLine 12]
   CreateSubNode $adPosNode "YPos" [lindex $adLine 13]
   DOM appendChild $adNode $adPosNode
   CreateSubNode $adNode "AdProdInfo" [lindex $adLine 14]
   CreateSubNode $adNode "AdGuaranteedPos" [lindex $adLine 15]
   CreateSubNode $adNode "AdNotUsed3" [lindex $adLine 16]
   CreateSubNode $adNode "AdCust1" [lindex $adLine 17]
   CreateSubNode $adNode "AdCust2" [lindex $adLine 18]
 
  CreateSubNode $adNode "AdCust3" [lindex $adLine 19]
}


proc MakeFullPagePlanXML { PlanDOM nopgpl Pageplcms Extlines } {
   # PPI plan does not have all pages and product size has changed
   # We have extracted the entire CCI plan. Now merge the PPI pages with CCI
   # pages and create full product. PagePlcms tells us sections and 
   # pagenumbers
   upvar $PlanDOM planDOM
   upvar $Pageplcms pageplcms
   upvar $Extlines extlines

   set planNode [DOM getelementsbytagname $planDOM Plan]
   set updateNode [DOM getelementsbytagname $planDOM Update]

   ## RM 6FEB2014 MakeFullPagePlanXML is always called from MergePagePlansXML
   ## and is a FullSectionUpdate
   PutTextInNode $updateNode "1"

   ## RM 13JAN2014 Loop through page placements in PPI PrProduct.
   for {set pno 1} {$pno <= $nopgpl} {incr pno} {
      set PageId $pageplcms($pno,PageId)
      # Use pageline from ppi file if found
      set i 0
      set found 0
      foreach pageNode [DOM getelementsbytagname $planDOM Page] {
         DecodePrintInfo [GetNodeValue $pageNode PagePrintInfo] extBestP \
                            extPageId extPageName extPageNo extState \
                            extOrderNo extDumpVer extSpread
         if {[cequal $PageId $extPageId]} {
            set found 1
         } 
      }

      ## RM 13JAN2014 "found" indicates a page placement where the page placed
      ## has an id corresponding to the PPI page id of a page in the PPI plan.
      if {!$found} {
         set i 0

         ## RM 13JAN2014 If a page placement has a page id not found in the PPI 
         ## plan, see if a page with the missing page id is already in the CCI
         ## database for the corresponding Zone/Edition. and add it to the
         ## incoming plan if it is. I do not think this should occur!!!!!
         while {$i < [llength $extlines]} {
            set line [lindex $extlines $i]
            set type [lindex $line 0]
            incr i
            if {[cequal $type "PAGE:"]} {
               DecodePrintInfo [lindex $line 8] extBestP extPageId \
                               extPageName extPageNo extState \
                               extOrderNo extDumpVer extSpread
               if {[cequal $PageId $extPageId]} {
                  set found 1
                  set line [lreplace $line 25 25 $pno]
                  # Replace ppi pageno in printing_info
                  set PrintInfo [EncodePrintInfo $extBestP $extPageId \
                                 $extPageName $pno $extState $extOrderNo \
                                 $extDumpVer $extSpread]
                  set line [lreplace $line 8 8 $PrintInfo]

                  ## RM 20MAR2011 Create a page node.
                  LogMsg "Page $extPageName with PPI ID $extPageId  not found in PPI plan but found in CCI."
                  set pageNode [DOM createElement $planNode "Page"]
                  MakeOnePageXMLFromCCIPlannerPageLine pageNode $line

                  ## RM 20MAR2011 Add ad nodes to the page node.
                  while {$i < [llength $extlines]} {
                     set line [lindex $extlines $i]
                     set type [lindex $line 0]
                     incr i
                     if ![cequal $type "AD:"] { break }
                     set adNode [DOM createElement $pageNode "Ad"]
                     MakeOneAdXMLFromCCIPlannerAdLine adNode $line
                     DOM appendChild $pageNode $adNode
                  }
                  DOM appendChild $planNode $pageNode
               }
               break
            }
         }
      }
      if {!$found} {
         LogErr "Error merging plans - Page with Id $PageId missing"
         return 1
      }
   }
   ## RM 13JAN2014 End of loop through page placements in PPI PrProduct.
}


###############################################################################
#
# Merge pageplan with existing product
# Merged fields: Template, LayoutTemplate, deadline
#
proc MergePagePlansXML { PlanDOM extractfile PartPage sizechanged pagepl nopgpl Page Update SectionNumeric PendingUpdates } {

   upvar $PlanDOM planDOM
   upvar $PartPage partpage
   upvar $pagepl pageplcms
   upvar $Page page
   upvar $Update update
   upvar $PendingUpdates pendingupdates
   
   global IGNOREDUMPVERSION
   global PlansRun

   LogDebug "Merging with existing product"

   if [catch {open $extractfile r} fpext] {
      LogErr "Cannot open file $extractfile"
      return 1
   }
   set extlines {}
   while {[gets $fpext line] >= 0} {
      set line [latin1toutf8 "$line"]
      set tokens [split "$line" \t]
      lappend extlines $tokens
      # Make sure existing header was made by this integration
      # Otherwise we quit
      if [cequal "PRINTING_INFO:" [lindex $tokens 0]] {
         set tokens [split [lindex $tokens 1] ";"]
         if {[llength $tokens] < 4} {
            LogErr "Existing CCI not made with XML integration - Trying anyway"
         }
      }
      if [cequal "FORMAT:" [lindex $tokens 0]] {
         set MaxHeight [lindex $tokens 1]
         set MaxWidth [lindex $tokens 2]
      }
   }
   close $fpext

   set newcolors 0
   set newpagenums 0
   set newsections 0
   set newnames 0
   set newspread 0
   ## set newlines {}
   set checkCCIspreads 0

   #set fpdebug [open /tmp/merge.dbg a]
   #cmdtrace on $fpdebug
   # Merge values from extracted CCI pages into pages found in PPI plan
   set Edition [GetNodeValue $planDOM Edition]

   ## RM 10JAN2014 loop through pages in PPI Product/TEC
   foreach pageNode [DOM getelementsbytagname $planDOM Page] {
      set pagename [GetNodeValue $pageNode PageId]
      set pageid [lindex [split [GetNodeValue $pageNode PagePrintInfo] ,] 0]
      set prodform [string trim [GetNodeValue $pageNode ProdForm]]
      set bookpage [GetNodeValue $pageNode BookPageNumber]
      set runpage [GetNodeValue $pageNode RunningPage]
      set section [GetNodeValue $pageNode PhysicalBook]
      set newDumpVersion [lindex [split [GetNodeValue $pageNode PagePrintInfo] ,] 5]
      set spread [GetNodeValue $pageNode SpreadPage]
      set newsrcdir [GetNodeValue $pageNode TextSourceDir]
      set newsrcpage [GetNodeValue $pageNode TextSourcePage]
      set templatePageNode [DOM getelementsbytagname $pageNode TemplatePage]
      set newContentTemplate [GetNodeValue $templatePageNode Content]
      set newLayoutTemplate [GetNodeValue $templatePageNode Layout]
      set cmyk [GetNodeValue $pageNode Cmyk]
      set spot1 [GetNodeValue $pageNode Spot1]
      set spot2 [GetNodeValue $pageNode Spot2]
      set spot3 [GetNodeValue $pageNode Spot3]
      set colorgrp [GetNodeValue $pageNode ColorGrp]

      set pagemerged 0
      set colorchange 0
      set pagenumchange 0
      set sectionchange 0
      set namechange 0
      set prodformchange 0
      set spreadchange 0
      set skipping 0
      set CCIspread 0

      ## RM 10JAN2014 For each page in PPI Product/TEC, loop through pages in
      ## edition extracted from CCI.
      for {set i 0} {$i < [llength $extlines]} {incr i} {
         set el [lindex $extlines $i]
         if {![cequal [lindex $el 0] "PAGE:"]} {
            continue
         }
         set extPageName [lindex $el 20]
         DecodePrintInfo [lindex $el 8] extBestP extPageId extPPIPageName \
                         extPageNo extState extOrderNo extDumpVersion extSpread

         ## RM 10JAN2014 Page recognised in CCI database by PageId extracted
         ## from PrintInfo attribute.
         if {[cequal $pageid $extPageId] || \
             $extPageId == 0 && [cequal $pagename $extPageName]} {
            set pagemerged 1
            if {![cequal $pagename $extPageName]} {
               set namechange 1
               LogDebug "Merge: PPI Page $pagename is CCI Page $extPageName"
            }
            set orgprodform [string trim [lindex $el 22]]
            if ![cequal $orgprodform $prodform] { set prodformchange 1 }
            set orgbookpage [lindex $el 2]
            set orgrunpage [lindex $el 25]
            if { ![cequal $orgbookpage $bookpage] || ![cequal $orgrunpage $runpage] } { set pagenumchange 1 }
            set orgsection [lindex $el 1]
            if ![cequal $orgsection $section] { set sectionchange 1 }
            set srcdir [lindex $el 23]
            set srcpage [lindex $el 24]
            set ccitemplates [split [lindex $el 21] /]
            set contentTemplate [lindex $ccitemplates 0]
            set layoutTemplate [lindex $ccitemplates 1]
            set orgspread [lindex $el 5]
            if {$namechange == 0 && $extSpread == 0 && $orgspread > 0} {
               # This page has spread created on CCI
               if {$spread == 0} {
                  # Not PPI spread - keep CCI spread
                  set checkCCIspreads 1
                  set CCIspread 1
               }
            } elseif {$spread != $orgspread} {
               set spreadchange 1
            }

            set pagecanupdate 1
            set pagestate [lindex $el 6]
            if {$pagestate == 3 || $pagestate == 4 || \
                $pagestate == 5 || $pagestate == 10} {
               set pagecanupdate 0
            }
            # merge printinfo with Best Practice stuff
            if {[clength $extBestP]} {
               set PrintInfo "${extBestP}#[GetNodeValue $pageNode PagePrintInfo]"
            } else {
               set PrintInfo [GetNodeValue $pageNode PagePrintInfo]
            }
            set pagePrintInfoNode [DOM getelementsbytagname $pageNode PagePrintInfo]
            if {!$pagecanupdate} {
               # Always keep extracted value to avoid update problem
               PutTextInNode $pagePrintInfoNode [lindex $el 8]
               if {![cequal $PrintInfo [lindex $el 8]]} {
                  lappend pendingupdates "111=$pagename 110=$pagename 15=0 16=11 2=$pagename \"96:#$PrintInfo; ; ; ; ; ; ; ;\""
               }
            } else {
               PutTextInNode $pagePrintInfoNode $PrintInfo
            }

            ## RM 13SEP2012 The decision to preserve the PPI page line also
            ## needs to take account of possible changes to the template pages
            ## so the following condition has been expanded.
            ## RM 25JUN2012 The idea here is that the page is unchanged so it is
            ## OK to take the contents of the PPI plan for this page. This is
            ## flawed reasoning for the contents of the PagePrintInfo field so
            ## the following condition has been moved after the update of this
            ## field.
            if {!$IGNOREDUMPVERSION && !$namechange && !$spreadchange && \
                !$CCIspread && \
                !$pagenumchange && !$sectionchange && !$prodformchange && \
                [cequal $srcdir $newsrcdir] && \
                [cequal $srcpage $newsrcpage] && \
                [cequal $contentTemplate $newContentTemplate] && \
                [cequal $layoutTemplate $newLayoutTemplate] && \
                $extDumpVersion == $newDumpVersion} {
               #LogDebug "Skip page $pagename - Same Dump"
               set skipping 1
               break
            }

            if [llength $ccitemplates] {
               set templatePageNode [DOM getelementsbytagname $pageNode TemplatePage]
               set contentTemplatePageNode [DOM getelementsbytagname $templatePageNode Content]
               set layoutTemplatePageNode [DOM getelementsbytagname $templatePageNode Layout]
               #if {[clength [lindex $ccitemplates 0]] > 0} {
               #   PutTextInNode $contentTemplatePageNode $contentTemplate
               #}
               if {[llength $ccitemplates] > 1} {
                 PutTextInNode $layoutTemplatePageNode $layoutTemplate
               }
            }

            if {$CCIspread} {
               set spreadPageNode [DOM getelementsbytagname $pageNode SpreadPage]
               PutTextInNode $spreadPageNode $orgspread
            }
            # If page in PPI plan is active and has no sourcing and
            # existing CCI-page is active with sourcing - keep
            # sourcing on CCI page.
            # Requires same sequence in all PPI files
            set active [GetNodeValue $pageNode Active]
            if {$active == 1 && [clength $newsrcdir] == 0 && \
                [lindex $el 31] == 1 &&  [clength $srcdir] > 0} {
               set textSourceDirNode [DOM getelementsbytagname $pageNode TextSourceDir]
               set textSourcePageNode [DOM getelementsbytagname $pageNode TextSourcePage]
               PutTextInNode $textSourceDirNode $srcdir
               PutTextInNode $textSourcePageNode $srcpage
            }

            ## RM 10JAN2014 NYT (or ROHE!) want a non-empty sourcing in CCI
            ## always to take precendent over a PPI sourcing, but this should be
            ## implemented in Plan Enrichment
            ## RM 10JAN2014 Correct merging error in XMLPlanEnrich!
            ## RM 10JAN2014 CONTINUE FROM HERE!!!!!
            # Troels Eriksen (CCI) 14.03.2012: ASV requested modification
            # If the page in the Database is active =>
            #    always use srcdir, srcpage and active values from the database
            #
            set existingpageactive [lindex $el 31]
            if {$existingpageactive} {
               set activeNode [DOM getelementsbytagname $pageNode Active]
               set textSourceDirNode [DOM getelementsbytagname $pageNode TextSourceDir]
               set textSourcePageNode [DOM getelementsbytagname $pageNode TextSourcePage]
               PutTextInNode $activeNode $existingpageactive
               PutTextInNode $textSourceDirNode $srcdir
               PutTextInNode $textSourcePageNode $srcpage
            }
            # See if colors was changed - then it is not an update
            set orgcmyk [lindex $el 9]
            if ![cequal $orgcmyk $cmyk] { set colorchange 1 }
            set orgspot1 [lindex $el 10]
            if ![cequal $orgspot1 $spot1] { set colorchange 1 }
            set orgspot2 [lindex $el 11]
            if ![cequal $orgspot2 $spot2] { set colorchange 1 }
            set orgspot3 [lindex $el 12]
            if ![cequal $orgspot3 $spot3] { set colorchange 1 }
            set orgcolorgrp [lindex $el 27]
            if ![cequal $orgcolorgrp $colorgrp] { set colorchange 1 }
            set extindx $i

            ## lappend newlines $line
            # Merge ads.
            while  {1} {
               set nextline [lindex $extlines [expr $i + 1]]
               set nexttype [lindex $nextline 0]
               # If next line is not an ad - break
               if {![cequal $nexttype "AD:"]} {
                  break
               }
               # Ad found - If partpage covering the position where
               # where ad is placed, then the extracted ad should not
               # be used
               if [cequal [lindex $nextline 12] "-"] {
                  # Ads in in componentlist
                  # Dont use it
                  incr i
                  continue
               }
               set xpos [format "%.0f" [expr [lindex $nextline 12] * 1000]]
               set ypos [format "%.0f" [expr [lindex $nextline 13] * 1000]]
               if {[cequal [lindex $nextline 8] "-"]} {
                  # Full size ad
                  set xsiz [format "%.0f" [expr $MaxWidth * 1000]]
               } else {
                  set xsiz [format "%.0f" [expr [lindex $nextline 8] * 1000]]
               }
               if {[cequal [lindex $nextline 9] "-"]} {
                  # Full size ad
                  set ysiz [format "%.0f" [expr $MaxHeight * 1000]]
               } else {
                  set ysiz [format "%.0f" [expr [lindex $nextline 9] * 1000]]
               }
               set skipcciad 0
               set PartPagePlcm [DOM getelementsbytagname \
                                $page($pageid,DOM) PartPagePlcm]
               foreach p $PartPagePlcm {
                  set Key [DOM getelementsbytagname $p PartPageKey]
                  set PartPageId [DOM getattribute $Key Id]
                  if ![info exists partpage($PartPageId,DOM)] {
                     continue
                  }
                  set MinX [DOM getattribute $p PosX]
                  set MinY [DOM getattribute $p PosY]
                  set pp $partpage($PartPageId,DOM)
                  set MaxY [expr [DOM getattribute $pp Height] + $MinY]
                  set MaxX [expr [DOM getattribute $pp Width] + $MinX]
                  # Test if any corner of the ad is inside partpage
                  # because it can actually be placed with part of ad
                  # outside partpage
                  if {$xpos <= $MaxX && [expr $xpos + $xsiz] >= $MinX && \
                      $ypos <= $MaxY && [expr $ypos + $ysiz] >= $MinY} {
                     set skipcciad 1
                     break
                  }
               }

               if {!$skipcciad} {
                  # Partpage where ad is positioned not present. This can be
                  # because there are no updates to the partpage or
                  # because the partpage was moved. Check adlines from
                  # PPI. If the ad is found here, the partpage was moved
                  # and we must skip the extracted adline.
                  set adname [lindex $nextline 1]
                  foreach adNode [DOM getelementsbytagname $planDOM Ad] {
                     set bookingNumber [GetNodeValue $adNode BookingNumber]
                     if {[cequal $bookingNumber $adname]} {
                        set skipcciad 1
                        break
                     }
                  }
               }
               if {!$skipcciad} {
                  # The partpage was not in new file - use extracted ad
                  #LogDebug "Merge: using ad [lindex $nextline 1] from CCI"
                  # RM 16MAR2011 Add ad node for this CCI ad.
                  set adNode [DOM createElement $pageNode "Ad"]
                  MakeOneAdXMLFromCCIPlannerAdLine adNode $nextline
                  DOM appendChild $pageNode $adNode
               } else {
                  #LogDebug "Merge: skip ad [lindex $nextline 1] from CCI"
               }
               incr i
            }
            break
         }
         ## RM 10JAN2014 End of processing page with particular PPI PageId.

      }
      ## RM 10JAN2014 End of loop through pages extracted from CCI database.

      if {!$pagemerged} {
         LogMsg "New page: $pagename"
         ##lappend newlines $line
         set sizechanged 1
      }
      if {$colorchange} {
         set newcolors 1
      }

      ## RM 16JAN2014 Noting out the next three lines to try to force an update.
      ## TO DO: Work out which of these changes which normally leads to making a
      ## full plan are invalid with section update.
      ## if {$pagenumchange} {}
      ##   set newpagenums 1
      ## {}

      if {$sectionchange} {
         set newsections 1
      }
      if {$namechange} {
         set newnames 1
      }
      if {$spreadchange} {
         set newspread 1
      }
      foreach adNode [DOM getelementsbytagname $pageNode Ad] {
         # Adline
         set adname [GetNodeValue $adNode BookingNumber]
         if {$skipping} {
            #LogDebug "Skip ad $adname on $pagename"
            continue
         }
         set adtype [GetNodeValue $adNode AdType]
         if {$pagemerged} {
            # Look for ad in extracted line
            for {set i [expr $extindx+1]} {$i<[llength $extlines]} {incr i} {
               set el [lindex $extlines $i]
               set type [lindex $el 0]
               if [cequal $type "PAGE:"] {
                  break
               }
               set extadname [lindex $el 1]
               if [cequal $adname $extadname] {
                  # RM 20MAR2011 Simple unconditional merging is now
                  # configured in the Configuration Manager parameter
                  # Integration.XMLPlanEnrich.MergeFieldsFromDatabase.
                  # Keep Description/AdRelated info from DB. PPI has no
                  # information for these fields anyway.

                  # If Classified block ad see if user has unmounted 
                  # and repect this by using the extracted adline
                  if {$adtype == 2 && [cequal [lindex $el 12] "-"]} {
                     # Ad is umounted and in componentlist
                     set adPosNode [DOM getelementsbytagname $adNode AdPos]
                     set xPosNode [DOM getelementsbytagname $adPosNode XPos]
                     set yPosNode [DOM getelementsbytagname $adPosNode YPos]
                     PutTextInNode $xPosNode "-"
                     PutTextInNode $yPosNode "-"
                  }
                  if {$pagecanupdate == 0} {
                     # Page is released/typeset. Do not update
                     # FirstPubDate, LastPubDate and CustomerName.
                     set firstPubDateNode [DOM getelementsbytagname $adNode FirstPubDate]
                     PutTextInNode $firstPubDateNode [lindex $el 4]

                     LogMsg "Ignore FirstPubDate update for ad $adname - page is typeset/released"
                     set lastPubDateNode [DOM getelementsbytagname $adNode LastPubDate]
                     PutTextInNode $lastPubDateNode [lindex $el 5]
                     LogMsg "Ignore LastPubDate update for ad $adname - page is typeset/released"
                     set customerNode [DOM getelementsbytagname $adNode Customer]
                     PutTextInNode $customerNode [lindex $el 6]
                     LogMsg "Ignore Customer update for ad $adname - page is typeset/released"
                  }
                  break
               }
            }
         }
         ##lappend newlines $line
      }
   }
   ## RM 10JAN2014 End of for loop through pages in PPI Product/TEC

   if {$sizechanged} {
      LogDebug "New page found - making full CCI plan"
   }
   if {$newcolors} {
      LogDebug "Colors updated - making full CCI plan"
   }
   if {$newpagenums} {
      LogDebug "Pagenumbers updated - making full CCI plan"
   }
   if {$newsections} {
      LogDebug "Sections updated - making full CCI plan"
   }
   if {$newnames} {
      LogDebug "Name changed on page - making full CCI plan"
   }
   if {$newspread} {
      LogDebug "Change in spread - making full CCI plan"
   }
   if {$sizechanged || $newcolors || $newpagenums || \
       $newsections || $newnames || $newspread} {

      ## RM 6FEB2014 A full page plan should now be regarded as a full section
      ## update
      set update 1
      MakeFullPagePlanXML planDOM $nopgpl pageplcms extlines
   }
   if {$checkCCIspreads} {
      # We have spreads defined on CCI. They are merged into new plan
      # check if they are still valid after this update
      # Both CCI spread pages must be present
      # They must both be CCI spreads only (not spread on PPI)
      # The spread must be a legal spread - mate must be same as before
      set spreadchange [ValidateCCISpreadsXML planDOM pageplcms]
      if { $spreadchange } {

         ## RM 6FEB2014 A full page plan should now be regarded as a full
         ## section update
         set update 1
         MakeFullPagePlanXML planDOM $nopgpl pageplcms extlines
      }
   }
   set pagesinplan 0
   foreach pageNode [DOM getelementsbytagname $planDOM Page] {
      set pagesinplan 1
   }
   if {$pagesinplan} {
      return 0
   } else {
      return 2
   }
   #cmdtrace off
   #close $fpdebug
}


###############################################################################
#
#  IsPagePlanSourcingFromXML
#  Finds out if a previous plan which this plan is sourcing from was not 
#  created - returns name of the zone if so
#
proc IsPagePlanSourcingFromXML { Product PlanDOM ListOfProducts} {
   upvar $Product product
   upvar $PlanDOM planDOM

   if {[llength $ListOfProducts] == 0} {
      return {}
   }

   set oldsrcdir {}
   set edition [GetNodeValue $planDOM Edition]
   foreach pageNode [DOM getelementsbytagname $planDOM Page] {
      set srcdir [GetNodeValue $pageNode TextSourceDir]
      if {[clength $srcdir] && ![cequal $srcdir $oldsrcdir]} {
         foreach prod $ListOfProducts {
            if {[cequal $srcdir $product($prod,Zone)] && \
                [cequal $edition $product($prod,Edition)]} {
               return "$product($prod,Zone) $product($prod,Edition)"
            }
         }
         set oldsrcdir $srcdir
      }
   }

   return {}
}


###############################################################################
#  Header format:
#
#  ["UPDATE:"<TAB><UPDATE_MODE><NL>]
#
#  "NEWSPAPER:"<TAB><NP_TITLE><NL>
#  "DATE:"<TAB><PUBLICATION_DATE><NL>
#  "ZONE:"<TAB><ZONE><NL>
#  "EDITION:"<TAB><EDITION><NL>
#  "FORMAT:"<TAB><FORMAT><NL>
#  "FILE_FORMAT:"<TAB>1.0<NL>
#
#  ["PAGES:"<TAB><NO_OF_PAGES><NL>]
#  ["SECTION:"<TAB><SECTION_INFO><NL>]
#  ["NUMBER:"<TAB><PROD_NUM><NL>]
#  ["PRINTING_INFO":<TAB><PRINT_INFO><NL>]
#  ["VERSION:"<TAB><CREATION_TIME><NL>]
#  ["CONFIG:"<TAB><CONFIG_CODE><NL>]
#  ["DEFAULT:"<TAB><DEFAULT_CODE><NL>]
#  ["ISSUE_NAME:"<TAB><ISSUE_INFO><NL>]
#
proc MakeOnePagePlanXML { Pageplans Product index Page PartPage FileFormat DumpMode destinationDirectory} {
   upvar $Product product\
         $Pageplans pageplans\
         $Page page\
         $PartPage partpage

   global TransStatus
   global WSM_RES
   global env
   global DEBUG
   global DONTRUNPLANS
   global IGNOREDUMPVERSION
   global errorCode
   global errorInfo
   global PlansNotRun
   global PlansRun
   global THIS_SCRIPT

   set TmpDir [pwd]

   # KK Unique file name
   ## RM 6JUN2011 alphabeticIndex introduced to ensure that the Planner
   ## processes the plans in the correct order.
   set alfa1 [expr $index / 26]
   set alfa2 [expr $index % 26]
   set alphabeticIndex "[format %c [expr 65 + $alfa1]][format %c [expr 65 + $alfa2]]"
   #set alphabeticIndex [format %c [expr 64 + $index]]

   ## RM 4DEC2012 The variable timeStamp is only introduced to work around a
   ## problem with storing the script in the delta system.
   set timeStamp [fmtclock [getclock] %y%m%d_%H_%M_%S]
   regsub -all "_" $timeStamp "" timeStamp
   set FileName "planXML.$product($index,Name).$product($index,PubDate).$product($index,DumpVersion).$alphabeticIndex.[pid].$timeStamp"
   #set FileName "planXML$alphabeticIndex.[pid].$timeStamp"

   set PagePlcms $product($index,PagePlcms)
   set NumOfPages [llength $PagePlcms]

   if {$NumOfPages < 1 } {
      # No pages found - just ignore
      LogMsg "No pages in file - plan skipped for PrProdTyp(Edition) \
              $product($index,Edition)"
      return
   }

   LogMsg "Start $product($index,Name) $product($index,PubDate) $product($index,Zone) $product($index,Edition) - $NumOfPages pages"

   set XMLPlanDomObj [DOM createDocument Plan]
   set rootNode [DOM getElementsByTagName $XMLPlanDomObj Plan]
   DOM setAttribute $rootNode xmlns "http://www.ccieurope.com/xmlns/CCIPlanner"
   DOM setAttribute $rootNode xmlns:cci "http://www.ccieurope.com/xmlns/CCIPlanner"
   DOM setAttribute $rootNode xmlns:xsi "http://www.w3.org/2001/XMLSchema-instance"

   ## RM 01MAR2011 Create the plan header node.
   set headerNode [DOM createElement $rootNode "Header"]
   # If we find out that it is an update, the Update value is changed below
   CreateSubNode $headerNode "Update" "0"
   CreateSubNode $headerNode "NewsPaper" "$product($index,Variant)"
   CreateSubNode $headerNode "Date" "$product($index,PubDate)"
   CreateSubNode $headerNode "Zone" "$product($index,Zone)"
   CreateSubNode $headerNode "Edition" "$product($index,Edition)"
   CreateSubNode $headerNode "Pages" "$NumOfPages"

   ## RM 16JAN2014 Simpler code for reading the section names, at least to
   ## begin with.
   CreateSubNode $headerNode "Section" "$product($index,SectionNames)"

   CreateSubNode $headerNode "Number" ""
   set formatNode [DOM createElement $headerNode "Format"]
   CreateSubNode $formatNode "Height" "$product($index,Height)"
   CreateSubNode $formatNode "Width" "$product($index,Width)"
   DOM appendChild $headerNode $formatNode
   CreateSubNode $headerNode "PrintingInfo" "$product($index,ID);$product($index,Zone);$product($index,Edition);$product($index,BookStruct);$product($index,DumpVersion)"
   CreateSubNode $headerNode "Version" ""
   CreateSubNode $headerNode "Config" ""
   CreateSubNode $headerNode "Default" "$product($index,Zone);$product($index,Edition)"
   CreateSubNode $headerNode "FileFormat" "$FileFormat"
   CreateSubNode $headerNode "IssueName" ""
   DOM appendChild $rootNode $headerNode

   set cursec ""
   set pagesfound 0

   ## RM 16JAN2014 I don't think that we need pagesInSect any more.
   if [catch {set sections [DOM getelementsbytagname $product($index,DOM) RSSections]}] {
      set sections {}
   }

   foreach p $PagePlcms {
      set Key [DOM getelementsbytagname $p PageKey]
      set PageId [DOM getattribute $Key Id]
      if {[info exist page($PageId)]} {
         set pagesfound 1
      }
      set runpageno [DOM getattribute $p PageNo]
      if [catch {set section [DOM getattribute $p RSSection]}] {
         set secpageno [DOM getattribute $p RelPageNo]
         set sectionNo [DOM getattribute $p SectionNo]
         if {![cequal $cursec $section]} {
            set pagesinsec [DOM getattribute $product($index,DOM) \
                                             PagesInSectionNo$sectionNo] 
         }
      } else {
         set secpageno [DOM getattribute $p RSPageNo]
         if {![cequal $cursec $section]} {
            if {$sections == {}} {
               set pagesinsec [DOM getattribute $product($index,DOM) \
                                                PagesInSectionNo$sectionNo] 
            } else {
               foreach s [DOM getelementsbytagname $sections RSSection] {
                  if {[cequal $section [DOM getattribute $s SectionName]]} {
                     set pagesinsec [DOM getattribute $s NumberOfPages]
                     break
                  }
               }
            }
         }
      }
      set cursec $section
      set pageplcm($runpageno,PageId) $PageId
      set pageplcm($runpageno,RunningPageNo) $runpageno
      set pageplcm($runpageno,BookPageNo) $secpageno
      set pageplcm($runpageno,Section) $section
      set pageplcm($runpageno,PagesInSect) $pagesinsec
      if [info exists $product($index,HdrSectionList)] {
         #HWN Add section to pageplcm array.
         set pageplcm($runpageno,Section) $page($PageId,Section)
         #HWN Use my new section page count array
         set pageplcm($runpageno,PagesInSect) $pagesInSect($section)
      }
      if {$secpageno <= [expr $pagesinsec / 2]} {
         if {$secpageno % 2} {
            set pageplcm($runpageno,Form) $product($index,PrimForm)
         } else {
            set pageplcm($runpageno,Form) $product($index,SecForm)
         }
      } else {
         if {$secpageno % 2} {
            set pageplcm($runpageno,Form) $product($index,SecForm)
         } else {
            set pageplcm($runpageno,Form) $product($index,PrimForm)
         }
      }
   }
   # Make the pages in sorted order
   for {set pno 1} {$pno <= [llength $PagePlcms]} {incr pno} {
      set PageId $pageplcm($pno,PageId)
      if {![info exist page($PageId)]} {
         continue
      }

      set pageNode [DOM createElement $rootNode "Page"]
      MakeOnePageXML pageNode product $index page pageplcm partpage $pno $FileFormat \
                  $product($index,Zone)
      ## RM 01MAR2011 Append the page node to the root node after all the
      ## ad nodes have been appended to the page node.
      DOM appendChild $rootNode $pageNode

      ## RM 01JUN2011 Delay storing sourcing information about the pages
      ## until the correct zone has been supplied by the import hook.
   }

   # ATTENTION: Don't rely on Zone/Edition before calling Hook-Function!!
   ## RM 02MAR2011 TO DO Decide what to pass on to hook.
   ## Knud can accept a planDOM argument.
   ## What about consistency with the non XML interface?
   LogMsg "Hook Function: $product($index,HookFunc)"
   if [clength $product($index,HookFunc)] {
      if [catch {set HookResult [uplevel eval $product($index,HookFunc) \
                                $pageplans $XMLPlanDomObj]} HookError] {
         LogMsg "Hookfunction $product($index,HookFunc) failed - $HookError"
      }
      ## RM 09MAR2011 It seems possible to update the zone and the edition in
      ## the hook so these are re-read into the product array.
      set THIS_SCRIPT PPI-PlanPagXML
      set product($index,Zone) [GetNodeValue $XMLPlanDomObj Zone]
      set product($index,Edition) [GetNodeValue $XMLPlanDomObj Edition]
   }


   for {set pno 1} {$pno <= [llength $PagePlcms]} {incr pno} {
      set PageId $pageplcm($pno,PageId)
      if {![info exist page($PageId)]} {
         continue
      }

      ## Prepare information for future sourcing
      ## RM 01JUN2011 Store sourcing information about the pages now that
      ## the correct zone has been supplied by the import hook.
      if {$page($PageId,SrcDir) == ""} {
         set page($PageId,SrcDir) $product($index,Zone)
         set page($PageId,SrcPageNo) $pageplcm($pno,BookPageNo)
         set page($PageId,SrcSection) $pageplcm($pno,Section)
         foreach PartPageId $page($PageId,EdPartPageIds) {
            if [cequal $partpage($PartPageId,FirstPageId) ""] {
               set partpage($PartPageId,FirstPageId) $PageId
            }
         }
      }
   }

   set extract 0
   set sizechange 0
   set Update 0
   # Try to find out if plan is alredy created in CCI database
   if [GetPlannerVar 41 $product($index,Variant) headerpath] {
      set headerpath {}
   }
   if [GetPlannerVar 220 $product($index,Variant) dateformat] {
      set dateformat {}
   }

   # RM 12APR2011 LastDumpVersion is now stored after the last semi-colon
   # semi-colon separator in attribute 93 of the PublicationDate object.
   set LastDumpVersion -1
   if {$headerpath != {}} {
      if {[scan $product($index,PubDate) "%2d%2d%2d" d m y] != 3} {
         LogErr "pubdate not legal"
      } else {
         set headerdate [fmtclock [cvtclock "$d $m $y" "%d %m %y"] $dateformat]
      }
      set headerpath $headerpath/$headerdate/$product($index,Zone)/$product($index,Edition)/PlanHeader
      TransWsm DisTrans if $headerpath
      if {$TransStatus == 0} { 
         LogDebug "PlanHeader is: '$headerpath'"
         set extract 1 
         set Update 1
         LogDebug "Update1 is: '$Update'"
         ## RM 13JAN2014 PrintInfo should contain 5-tuples separated by
         ## semi-colons, the individual elements of a 5-tuple separated by
         ## commas:-PrProductID, PrProduct,TEC,BookStruct,DumpVersion.
         ## RM 10JAN2014 TO CONSIDER: With multiple mappings to the same
         ## Zone/Edition, this changes. The condition is flawed as such and the
         ## merge is just for the sections covered in the PrProduct being
         ## processed.
         # If update = 1 - look in the old header to find out if BookStruct
         # has changed. If so we need to extract whole plan and merge to a
         # full product
         TransWsm DisTrans ex $headerpath F[pwd]/PlanHeader.[pid]
         if {$TransStatus == 0} {
            set fphdr [open [pwd]/PlanHeader.[pid] r]
            while {[gets $fphdr line] >= 0} {
               set line [latin1toutf8 "$line"]
               set tokens [split "$line" \t]
               if [cequal [lindex $tokens 0] "PRINTING_INFO:"] {
                  set printinfo [split [lindex $tokens 1] ";"] 
                  set bookstruct [lindex $printinfo 3]
                  set LastDumpVersion [lindex $printinfo 4]
                  if {![cequal $bookstruct $product($index,BookStruct)]} {
                     # BookStructure changed - no longer an update

                     ## RM 6FEB2014 A change in BookStructure should generate a
                     ## full section update rather than a full plan.
                     ## does not generate a full plan.
                     LogMsg "BookStructure changed - Full section update"
                     set Update 1
                     ## LogMsg "BookStructure changed - Full plan is created"
                     ## set Update 0
                     set sizechange 1
                  }
                  break
               }
            }
            catch {close $fphdr}
            catch {file delete [pwd]/PlanHeader.[pid]}
         }
      } else { LogDebug "No PlanHeader: '$headerpath'" }
   }

   if {!$pagesfound && !$sizechange} {
      # No pages found - just ignore
      LogDebug "No pages in file - plan skipped"
      return
   }

   if {!$IGNOREDUMPVERSION && \
       $product($index,DumpVersion) == $LastDumpVersion} {
      set DependsOn [IsPagePlanSourcingFromXML product XMLPlanDomObj $PlansRun]
      if {[clength $DependsOn]} {
         if {$product($index,DumpVersion) == $LastDumpVersion} {
            LogMsg "Running pageplan with same dumpversion - $DependsOn was changed"
         }
      } else {
         LogMsg "No update - Same DumpVersion: $product($index,DumpVersion)"
         return
      }
   }

   LogDebug "Update2 is: '$Update'"
   if {$Update} {
      LogMsg "Updating $product($index,Name) $product($index,PubDate) $product($index,Zone) $product($index,Edition) - $NumOfPages pages"
   } else {
      LogMsg "Creating $product($index,Name) $product($index,PubDate) $product($index,Zone) $product($index,Edition) - $NumOfPages pages"
   }

   if [GetPlannerVar 10 $product($index,Variant) ProductName] {
      set ProductName "ProductName Not Found"
   }
   set PendingUpdates {}
   if {$extract} {
      eval TransWsm Extract -X -N $product($index,Variant) \
                       -D $product($index,PubDate) \
                       -Z $product($index,Zone) \
                       -E $product($index,Edition) -A \
                       -S $TmpDir -P ${FileName}.ext
      LogDebug "TransStatus is: '$TransStatus'"
      if {$TransStatus == 0} {
         set res [MergePagePlansXML XMLPlanDomObj  $TmpDir/${FileName}.ext \
                         partpage $sizechange pageplcm [llength $PagePlcms] \
                         page Update $product($index,SectionNumeric) \
                         PendingUpdates]
         if {$DEBUG} {
            if [file exists /tmp/plan$index.[pid].ext] {
               catch {file delete /tmp/plan$index.[pid].ext}
            }
            file copy $TmpDir/$FileName.ext /tmp/plan$index.[pid].ext
         }
         catch {file delete $TmpDir/${FileName}.ext}
         if {$res == 2} {
            LogMsg "Pageplan ignored - no pages updated"
            if [file exists $TmpDir/${FileName}.ext] {
               catch {file delete $TmpDir/${FileName}.ext}
            }
            if [file exists $TmpDir/${FileName}] {
               catch {file delete $TmpDir/${FileName}}
            }
            return 0
         }
      } else {
         LogDebug "DumpMode2 is: '$DumpMode'"
         if {[cequal $DumpMode "all"]} { set Update 0 }
      }
   }


   ## RM 16JAN2014 Think the PutTextInNode line below contained an error.
   LogDebug "Update3 is: '$Update'"
   if { $Update ==  "1" } {
      set updateNode [DOM getelementsbytagname $XMLPlanDomObj Update]
      PutTextInNode $updateNode "1"
   }

   ## RM 22MAR2011 Write the XML file. 
   if [catch { set fh [open $TmpDir/$FileName "w" ]}] {
      LogErr "Cannot open file"
      exit 1
   }
   DOM print -set FormatPrettyPrint $XMLPlanDomObj $fh
   close $fh
   DOM close $XMLPlanDomObj

   if {$DEBUG} {
      if [file exists /tmp/plan$index.[pid]] {
         catch {file delete /tmp/plan$index.[pid]}
      }
      LogMsg "file copy $TmpDir/$FileName /tmp/plan$index.[pid]"
      file copy $TmpDir/$FileName /tmp/plan$index.[pid]
   }
   if {$DONTRUNPLANS} {
      foreach pu $PendingUpdates {
         LogDebug "Pending update: $pu"
      }
      lappend PlansRun $index
      return 0
   }
   LogMsg "Before IsPagePlanSourcingFromXML"
   set DependsOn [IsPagePlanSourcingFromXML product XMLPlanDomObj $PlansNotRun]
   LogMsg "DependsOn: $DependsOn"
   if {[clength $DependsOn]} {
      if [file exists $TmpDir/${FileName}.ext] {
         catch {file delete $TmpDir/${FileName}.ext}
      }
      catch {file delete $TmpDir/$FileName}
      set errorCode 200
      set errorInfo [TransMsg -f PlanProcessingMailMessages.txt -n PLANPAGXML_NO_PRODUCT_CREATED_ERRORINFO -d "Failed to create product."]
      set ErrMsg [TransMsg -f PlanProcessingMailMessages.txt -n PLANPAGXML_NO_PRODUCT_CREATED_ERRORMSG -d "Failed to create %s %s %s %s\nDepends on %s." $product($index,Name) $product($index,PubDate) $product($index,Zone) $product($index,Edition) $DependsOn]
      ReportError $ErrMsg
      set errorCode 0
      set errorInfo {}
      lappend PlansNotRun $index
      return 0
   }

   LogMsg "file copy $TmpDir/$FileName $destinationDirectory"
   file copy $TmpDir/$FileName $destinationDirectory

   if [file exists $TmpDir/${FileName}.ext] {
      catch {file delete $TmpDir/${FileName}.ext}
   }
   if [file exists $TmpDir/${FileName}] {
      catch {file delete $TmpDir/${FileName}}
   }

   ## RM 22MAR2011 TO CONSIDER: Sending the plans to the XMLPlanImportSpooler
   ## means not stopping later dependent zones if earlier zones fail.
   ## RM 22MAR2011 TO DO: The planner is not run so we have the following
   ## update problems:-
   ## 1) The Description attribute of the header file with the DumpVersion.
   ## 2) Attribute 96 (PrintInfo) of pages being updated.
   ## if { $TransStatus == 0 } {

      # Save DumpVersion as description on PlanHeader object
      ## RM 22MAR2011 TO DO: Copy the XML file to the XMLPlanImport Spooler.
      ## TransWsm DisTrans ch $headerpath 4:$product($index,DumpVersion)

      ## if [GetPlannerVar 10 $product($index,Variant) ProductName] {
      ##    set ProductName "ProductName Not Found"
      ## }
      foreach pu $PendingUpdates {
         LogDebug "Pending update: $pu"

         ## eval TransWsm DisTrans ch -one 113=P 103=$ProductName \
         ##                                101=$ProductName \
         ##                                105=$headerdate \
         ##                                104=$headerdate \
         ##                                107=$product($index,Zone) \
         ##                                106=$product($index,Zone) \
         ##                                109=$product($index,Edition) \
         ##                                108=$product($index,Edition) \
         ##                                $pu
      }
      if {$Update} {
         LogMsg "Pageplan succesfully updated in CCI"
      } else {
         LogMsg "Pageplan succesfully created in CCI"
      }
      lappend PlansRun $index
   ## } else {
   ##    set errorCode 250
   ##    set errorInfo "Failed to create $product($index,Name) $product($index,PubDate) $product($index,Zone) $product($index,Edition) - DumpVersion $product($index,DumpVersion)"
   ##    ReportError "PagePlan was not created" 
   ##    set errorCode 0
   ##    set errorInfo {}
   ##    lappend PlansNotRun $index
   ## }
   return 0
}


proc MakeAllPagePlans { destinationDirectory PagePlans } {

   upvar $PagePlans pageplans

   global ColourList
   global ErrProduct

   set PPExport [DOM getelementsbytagname $pageplans PPExport]
   if {[llength $PPExport] != 1} {
      LogErr [TransMsg -f PPI-PlanPag.txt -n PPEXPORT \
                       -d "There must be one PPExport %s" [llength $PPExport]]
      return 1
   }

   set Head [DOM getelementsbytagname $pageplans Head]
   set DumpMode [DOM getattribute $Head Mode]
   LogDebug "DumpMode is: '$DumpMode'"

   if [catch {ConfigGetValue Integration.PPI-PlanPag.Hooks(PlanPagImport)} HookFunc] {
      set HookFunc ""
   }

   set Products [DOM getelementsbytagname $pageplans IssueObject]
   if {[llength $Products] != 1} {
      LogErr [TransMsg -f PPI-PlanPag.txt -n ISSUEOBJECT \
                       -d "There must be one IssueObject %s" [llength $Products]]
      return 1
   }

   set ProductName [DOM getattribute $Products Product]
   set ErrProduct $ProductName
   set Date [DOM getattribute $Products DateOfIssue]
   if {[scan $Date "%4d%2d%2d" Y m d] != 3} {
      LogErr "DateOfIssue not legal"
      return 1
   } else {
      set PubDate [fmtclock [cvtclock "$Y $m $d" "%Y %m %d"] "\%d\%m\%y"]
   }

   if [catch {ConfigGetValue CciApps.PlanEdit.Setup(UseLayoutTemplatePages)} \
                                                    UseLayoutTemplates] {
      LogErr [TransMsg -f PPI-PlanPag.txt -n USELAYOUTTEMPLATES \
              -d "Cannot read UseLayoutTemplatePages from ConfigBase"]
      LogErr $UseLayoutTemplates
      return 1
   }

   if [catch {ConfigGetValue CciApps.PlanEdit.Setup(FileFormat)} \
                                                    FileFormat] {
      set FileFormat 1.0
   }

   # Size is not available and Planner do not care
   # RM 24MAR2011 XMLPlanImport cares about having a unit.
   set Height 0m
   set Width 0m
   
   LogDebug "ProductName: $ProductName"
   LogDebug "Date: $Date"

   set PrProducts [DOM getelementsbytagname $pageplans PrProduct]
   set NumOfPrProducts [llength $PrProducts]
   LogDebug "Number of PrProducts [llength $PrProducts]"
   set prod 1
   foreach p $PrProducts {
      set Key [DOM getelementsbytagname $p Key]

      ## 4FEB2009 RM State "D" indicates a deleted print product.
      set PrProductState [DOM getattribute $p State]
      if [cequal $PrProductState "D"] {
         continue
      }

      set TEC [DOM getattribute $p TEC]
      if [catch {ConfigGetRecord -keyed Integration.PPI-PlanPag.ProductMapping($ProductName-$TEC)} fields] {
         if [catch {ConfigGetRecord -keyed Integration.PPI-PlanPag.ProductMapping($ProductName-*)} fields] {
            LogErr [TransMsg -f PPI-PlanPag.txt -n PRODUCTMAPPING \
             -d "Cannot read ProductMapping for %s %s" $ProductName $TEC]
            error "[TransMsg -f PPI-PlanPag.txt -n PRODUCTMAPPING -d "Cannot read ProductMapping for %s %s" $ProductName $TEC]" "PagePlan was not created" 10
         }
      }
      set Variant [keylget fields "Variant"]
      if [cequal $Variant ""] {
          LogErr [TransMsg -f PPI-PlanPag.txt -n NOCCIPRODUCT \
                  -d "Product Variant not found for %s " $ProductName]
          error "[TransMsg -f PPI-PlanPag.txt -n NOCCIPRODUCT -d "Product Variant not found for %s " $ProductName]" "PagePlan was not created" 20
      }

      if [catch {ConfigGetRecord -variant $Variant -keyed \
         Integration.PPI-PlanPag.ProductSetup} prodsetup] {
         LogErr [TransMsg -f PPI-PlanPag.txt -n PRODUCTSETUP \
             -d "Product Setup was not found for %s " $Variant]
         error "[TransMsg -f PPI-PlanPag.txt -n PRODUCTSETUP -d "Product Setup was not found for %s " $Variant]" "PagePlan was not created" 30
      }

      set Product($prod,DOM) $p
      set Product($prod,ID) [DOM getattribute $Key Id]
      set Product($prod,Name) $ProductName
      set Product($prod,PubDate) $PubDate
      set Product($prod,Zone) [DOM getattribute $p TEC]
      set Product($prod,DumpVersion) [DOM getattribute $p DumpVersion]
      set Product($prod,BookStruct) [DOM getattribute $p BookStruct]
      set Product($prod,Edition) [DOM getattribute $p PrProdTyp]
      set Product($prod,Height) $Height
      set Product($prod,Width) $Width
      set Product($prod,PagePlcms) [DOM getelementsbytagname $p PagePlcm]
      set Product($prod,Variant) $Variant
      set Product($prod,AdRules) [keylget prodsetup "AdRules"]
      set Product($prod,PrimForm) [keylget prodsetup "PrimaryForm"]
      set Product($prod,SecForm) [keylget prodsetup "SecondaryForm"]
      set Product($prod,Template) [keylget prodsetup "Template"]
      set Product($prod,Desk) [keylget prodsetup "Desk"]
      set Product($prod,SectionNumeric) [keylget prodsetup "SectionNameNumeric"]

      ## 16JAN2014 RM Loading the section names in a product into the product
      ## array. This is needed by the planner with section updates.
      set RSSections [DOM getelementsbytagname $p RSSection]
      set sectionList {}
      foreach section $RSSections {
         lappend sectionList [DOM getattribute $section SectionName]
      }
      set Product($prod,SectionNames) [join $sectionList " "]


      set Deadlineoffset [keylget prodsetup "Deadlineoffset"]
      if {[scan $PubDate "%2d%2d%2d" d m y] != 3} {
         LogErr "PubDate not legal"
         return 1
      } else {
         set Product($prod,Deadline) [fmtclock [expr [cvtclock "$d $m $y" \
            "%d %m %y"]+ (3600 * $Deadlineoffset)] \%d\%m\%y\%H\%M] 
      }
      set PublDateoffset [keylget prodsetup "Publicationdateoffset"]
      set Product($prod,PublDateoffset) $PublDateoffset
      set Product($prod,LastPublDate) [fmtclock [expr [cvtclock "$d $m $y" \
            "%d %m %y"]+ (86400 * $PublDateoffset)] \%d\%m\%y] 
      set Product($prod,MakeClassAd) [keylget prodsetup "CreateAdsForMakeUp"]
      set Product($prod,IgnoreAdsInClass) [keylget prodsetup "IgnoreAdsInMakeUp"]
      set Product($prod,UseLayoutTemplates) $UseLayoutTemplates
      set Product($prod,HookFunc) $HookFunc
      set LargestPrProductIndex $prod
      set prod [expr $prod + 1]
   }

   set basedata [DOM getelementsbytagname $pageplans BaseData]
   set colors [DOM getelementsbytagname $basedata Colour]
   foreach c $colors {
      set name [DOM getattribute $c ShortName]
      set ColourName [DOM getattribute $c EditSystemName]
      if [regexp {([1-9][0-9]*)} $ColourName colno] {
         set ColourList($name,CCIColor) $colno
      } else {
         set ColourList($name,CCIColor) $ColourName
      }
      set ColourList($name,Type) [DOM getattribute $c ScaleFlag]
   }

   set Pages [DOM getelementsbytagname $pageplans Page]
   foreach p $Pages {
      set Key [DOM getelementsbytagname $p Key]
      set id [DOM getattribute $Key Id]
      set orderno [DOM getattribute $Key OrderNo]
      set Page($id) $id
      set Page($id,OrderNo) $orderno
      set Page($id,DOM) $p
      set Page($id,SrcDir) ""
      set Page($id,Section) [DOM getattribute $p PageNumberTyp]
      set Page($id,EdPartPageIds) [list]
   }
   LogDebug "Number of Pages [llength $Pages]"

   #HWN Check if RSSections tag is present
   if [catch {set sections [DOM getelementsbytagname $prod(1,DOM) RSSections]}] {
      set sections {}
   # HWN Traverse products and build section list 
   for { set prod 1 } { $prod <= $LargestPrProductIndex } { incr prod } {
      set Product($prod,HdrSectionList) [list]
      foreach pgplcm $Product($prod,PagePlcms) {
         # Find the page
         set pgKey [DOM getelementsbytagname $pgplcm PageKey]
         set pgId [DOM getattribute $pgKey Id]
         # Find the sectionname 
         set sect $Page($pgId,Section) 
         if {[lsearch $Product($prod,HdrSectionList) $sect] < 0} {
            lappend Product($prod,HdrSectionList) $sect
         }
      }
      set Product($prod,HdrSectionList) [lsort $Product($prod,HdrSectionList)]
   }
   }
   set PartPages [DOM getelementsbytagname $pageplans PartPage]
   foreach p $PartPages {
      set Key [DOM getelementsbytagname $p Key]
      set id [DOM getattribute $Key Id]
      set PartPage($id) $id
      set PartPage($id,DOM) $p
      set PartPage($id,Placements) [DOM getelementsbytagname $p Placement]
      set PartPage($id,FirstPageId) ""
   }
   LogDebug "Number of Placements [llength $PartPages]"

   for { set p 1 } { $p <= $LargestPrProductIndex } { incr p } {
      MakeOnePagePlanXML pageplans Product $p Page PartPage $FileFormat $DumpMode $destinationDirectory
   }

   LogMsg "All pageplans has been processed"

   return 0
}


proc SetPPIInfo {cciproduct ccidate zone edition page id name orderno setid} \
{
   global WSM_RES
   global TransStatus
   global DONTRUNPLANS

   set Space " "
   TransWsm DisTrans ex -one 113=P 103=$cciproduct 105=$ccidate 107=$zone  \
                             109=$edition 16=11 111=$page 121=$Space 2=$page \
                             101=$cciproduct 104=$ccidate 106=$zone \
                             108=$edition 110=$page 118=$Space 96:
   if {$TransStatus != 0} { 
      error "Unable to extract pageinfo for $cciproduct $ccidate $zone $edition $page" "Unable to extract pageinfo for $cciproduct $ccidate $zone $edition $page" 512
   }
   
   LogDebug "Old PrintInfo: [lindex $WSM_RES 1]"
   set PrintInfo [split [lindex $WSM_RES 1] ";"]
   set PagePrintInfo [split [lindex $PrintInfo 0] "#"]
   set state 0
   if {$orderno > 0} {
      set state 1
   }
   if {[llength $PagePrintInfo] == 18} {
      # Set State and OrderNo
      set PPIInfo [lreplace [split [lindex $PagePrintInfo 17] ","] 3 4 $state $orderno]
      if {$setid} {
         set PPIInfo [lreplace $PPIInfo 0 1 $id $name]
      }
      set PagePrintInfo [lreplace $PagePrintInfo 17 17 [join $PPIInfo ","]]
   } else {
      # Set State and OrderNo
      set PPIInfo [lreplace [split [lindex $PagePrintInfo 1] ","] 3 4 $state $orderno]
      if {$setid} {
         set PPIInfo [lreplace $PPIInfo 0 1 $id $name]
      }
      set PagePrintInfo [lreplace $PagePrintInfo 1 1 [join $PPIInfo ","]]
   }
   set PagePrintInfo [join $PagePrintInfo "#"]
   set PrintInfo [join [lreplace $PrintInfo 0 0 $PagePrintInfo] ";"]

   LogDebug "New PrintInfo: $PrintInfo"
   if {$DONTRUNPLANS} {
      return
   }
   TransWsm DisTrans ch -one 113=P 103=$cciproduct 105=$ccidate 107=$zone  \
                             109=$edition 16=11 111=$page 121=$Space 2=$page \
                             101=$cciproduct 104=$ccidate 106=$zone \
                             108=$edition 110=$page 118=$Space 96:$PrintInfo
   if {$TransStatus != 0} {
      error "Unable to update pageinfo for $cciproduct $ccidate $zone $edition $page" "Unable to update pageinfo for $cciproduct $ccidate $zone $edition $page" 513
   }
}


proc ErrorOnPage { ReplyDOM PageType ElementType } {

   upvar $ReplyDOM replyDOM
   upvar $AttributeNames elementTypeDependentAttributeNames
   global DEBUG

   set Page [lindex [DOM getelementsbytagname $replyDOM $PageType] 0]
   set IdAttribute $elementTypeDependentAttributeNames($ElementType,Id)
   set NameAttribute $elementTypeDependentAttributeNames($ElementType,Name)
   set ModificationErrorAttribute $elementTypeDependentAttributeNames($ElementType,ModificationError)

   if [catch {set Ids [DOM getelementsbytagname $Page $IdAttribute]} {
      return 0
   }
   foreach Id $Ids {
      set Denomination [DOM getelementsbytagname $Id Denomination]
      set AdName [DOM getattribute $Denomination $NameAttribute]
      set AdModError [DOM getelementsbytagname $replyDOM $ModificationErrorAttribute]
      foreach AdError $AdModError {
         set Result [DOM getattribute $AdError Value]
         if {$Result != 0} {
            set AdErrorName [DOM getattribute $AdError $NameAttribute]
            if {[cequal $AdName $AdErrorName]} {
               return 1
            }
         }
      }
   }
   return 0 
}


proc GetAttributeName {elementType attributeSemantic} {
   switch -exact -- $elementType {
      A {
         switch -exact -- $attributeSemantic {
            Id {
               set AttributeName DisplayAdId
            }
            Name {
               set AttributeName ShortName
            }
            ModificationError {
               set AttributeName AdModificationError
            }
            default {
               set AttributeName "NOT DEFINED"
            }
         }
      }
      F {
         switch -exact -- $attributeSemantic {
            Id {
               set AttributeName APFillerId
            }
            Name {
               set AttributeName SystemNo
            }
            ModificationError {
               set AttributeName APFillerModificationError
            }
            default {
               set AttributeName "NOT DEFINED"
            }
         }
      }
      T {
         switch -exact -- $attributeSemantic {
            Id {
               set AttributeName ArticleId
            }
            Name {
               set AttributeName ShortName
            }
            ModificationError {
               set AttributeName ArticleModificationError
            }
            default {
               set AttributeName "NOT DEFINED"
            }
         }
      }
      default {
         set AttributeName "NOT DEFINED"
      }
   }
   return $AttributeName
}


proc CollectErrors { ReplyDOM ElementType } {
   upvar $ReplyDOM replyDOM
   upvar $AttributeNames elementTypeDependentAttributeNames

   global  errorCode errorInfo

   set AdErrors 0
   set NameAttribute $elementTypeDependentAttributeNames($ElementType,Name)
   set ModificationErrorAttribute $elementTypeDependentAttributeNames($ElementType,ModificationError)
   set Errors [DOM getelementsbytagname $replyDOM $ModificationErrorAttribute]
   foreach AdError $Errors {
      set AdName [DOM getattribute $AdError $NameAttribute]
      set Result [DOM getattribute $AdError Value]
      if {$Result} {
         set errorCode 300
         set errorInfo [TransMsg -f PlanProcessingMailMessages.txt -n PLANPAGXML_AD_NOT_UPDATED_ERRORINFO -d "Ad not updated."]
         set ErrMsg [TransMsg -f PlanProcessingMailMessages.txt -n PLANPAGXML_AD_NOT_UPDATED_ERRORMSG -d "PPI-PlanPagXML was unable to update ad %s." $AdName]
         ReportError $ErrMsg
         set AdErrors 1
         continue
      } else {
         LogDebug "Ad $AdName successfully updated in PPI-PlanPag"
      }
   }
   return $AdErrors
}


proc ProcessReply { file ReplyDOM } {

   upvar $ReplyDOM replyDOM
   global DEBUG

   set FileName [file tail [file rootname $file]]

   if [catch {ConfigGetValue Integration.PPI-PlanPag.Hooks(PlanPagImport)} HookFunc] {
      set HookFunc ""
   }

   set IssueObj [DOM getelementsbytagname $replyDOM IssueObject]
   if {[llength $IssueObj] != 1} {
      LogErr [TransMsg -f PPI-PlanPag.txt -n ISSUEOBJECT \
                   -d "There must be one IssueObject %s" [llength $IssueObj]]
      return 1
   }

   set Id [lindex [DOM getelementsbytagname $IssueObj Id] 0]
   set Denom [DOM getelementsbytagname $Id Denomination]
   set PPIProduct [DOM getattribute $Denom Product]
   set Date [DOM getattribute $Denom DateOfIssue]
   if {[scan $Date "%4d%2d%2d" Y m d] != 3} {
      LogErr "DateOfIssue not legal"
      return 1
   } 

   set Reply [lindex [DOM getelementsbytagname $IssueObj Reply] 0]
   set PageZoningError [DOM getelementsbytagname $Reply PageZoningError]
   foreach PZError $PageZoningError {
      set Result [DOM getattribute $PZError Value]
      set CCIProductInfo [DOM getattribute $PZError RSPageName]
      set Product [lindex $CCIProductInfo 0]
      set Zone [lindex $CCIProductInfo 1]
      set Edition [lindex $CCIProductInfo 2]
      set Page [lindex $CCIProductInfo 3]

      # Find CCI Product Name
      if [GetPlannerVar 10 $Product ProductName] {
         set ProductName "ProductName Not Found"
      }
      if [GetPlannerVar 220 $Product dateformat] {
         set dateformat \%m-\%d-\%y
      }
      set PubDate [fmtclock [cvtclock "$d $m $Y" "%d %m %Y"] $dateformat]

      if {$Result} {
         set errorCode 400
         set errorInfo [TransMsg -f PlanProcessingMailMessages.txt -n PLANPAGXML_PAGE_NOT_ZONED_ERRORINFO -d "Page not zoned."]
         set ErrMsg [TransMsg -f PlanProcessingMailMessages.txt -n PLANPAGXML_PAGE_NOT_ZONED_ERRORMSG -d "PPI-PlanPagXML was unable to zone page %s in %s %s %s %s - PPI-PlanPag error: %s" $Page $ProductName $PubDate $Zone $Edition $Result]
         ReportError $ErrMsg
         set errorCode 0
         set errorInfo {}
         continue
      }
      LogDebug "Page $Page in $ProductName $PubDate $Zone $Edition was succelfully zoned in PPI-PlanPag"

      set PPIPageId [DOM getattribute $PZError PPIPageId]
      set PPIPageName [DOM getattribute $PZError PPIPageName]
      set PPIOrderNo [DOM getattribute $PZError PPIOrderNo]
      SetPPIInfo $ProductName $PubDate $Zone $Edition $Page $PPIPageId \
                 $PPIPageName $PPIOrderNo 1
      if ![catch {set SpreadPageId [DOM getattribute $PageZoningError AdjacentPPIPageId]}] {
         set SpreadPageName [DOM getattribute $PageZoningError AdjacentPPIPageName]
         set SpreadOrderNo [DOM getattribute $PageZoningError AdjacentPagePPIOrderNo]
         set CCIProductInfo [DOM getattribute $PageZoningError AdjacentRSPageName]
         set SpreadPage [lindex $CCIProductInfo 3]
         LogDebug "Page $SpreadPage in $ProductName $PubDate $Zone $Edition was succelfully zoned in PPI-PlanPag"
         SetPPIInfo $ProductName $PubDate $Zone $Edition $SpreadPage \
                    $SpreadPageId $SpreadPageName $SpreadOrderNo 1
      }
      
   }

   ## 18FEB2009 RM Full list of element types for future
   ##set ElementTypes [list A(Ad) B(Blockade) F(Filler) H(Class Header) L(Line) S (SquareOff) T(Article)]
   ## 18FEB2009 RM ElementTypes fully supported in PPI version 2.9.5
   set SupportedElementTypes [list A F T]
   set ElementTypeDependentAttributes [Id Name ModificationError]
   foreach elementType $SupportedElementTypes {
      foreach attributeSemantic $ElementTypeDependentAttributes {
         set AttributeNames($elementType,$attributeSemantic) [GetAttributeName $elementType $attributeSemantic]
      }
      set Errors($elementType) [CollectErrors Reply $elementType]
   }

   set PageModification [DOM getelementsbytagname $Reply PageModification]
   foreach PageMod $PageModification {
      set errorOnPage 0
      if [catch {set CCIProductInfo [DOM getattribute $PageMod RSPageName]}] {
         if [catch {set CCIProductInfo [DOM getattribute $PageMod AdjacentRSPageName]}] {
            continue
         }
         set PageType AdjacentPage
      } else {
         set PageType Page
      }

      foreach elementType $SupportedElementTypes {
         if { $Errors($elementType) } {
            if {[ErrorOnPage replyDOM $PageType $elementType]} {
               LogDebug "AdError on page $CCIProductInfo - page not updated"
               set errorOnPage 1
               break
            }
         }
      }
      if {$errorOnPage} {
         continue
      }

      set Product [lindex $CCIProductInfo 0]
      set Zone [lindex $CCIProductInfo 1]
      set Edition [lindex $CCIProductInfo 2]
      set Page [lindex $CCIProductInfo 3]

      # Find CCI Product Name
      if [GetPlannerVar 10 $Product ProductName] {
         set ProductName "ProductName Not Found"
      }
      if [GetPlannerVar 220 $Product dateformat] {
         set dateformat \%m-\%d-\%y
      }
      set PubDate [fmtclock [cvtclock "$d $m $Y" "%d %m %Y"] $dateformat]
      if [catch {set PPIOrderNo [DOM getattribute $PageMod PPIOrderNo]}] {
         if [catch {set PPIOrderNo [DOM getattribute $PageMod AdjacentPagePPIOrderNo]}] {
            continue
         }
      }
      SetPPIInfo $ProductName $PubDate $Zone $Edition $Page {} {} $PPIOrderNo 0
   }
   return 0
}


proc PPI-PlanPagXML args  {

   global ColourList
   global errorInfo errorCode
   global Rejected
   global PlansNotRun
   global PlansRun
   global DEBUG
   global DONTRUNPLANS
   global NOTEMPLATES
   global IGNOREDUMPVERSION

   set errorCode 0
   set errorInfo {}
   set PlansNotRun {}
   set PlansRun {}

   set ErrorMsg {}

   set DEBUG [file exists /tmp/PPIXML-DEBUG]
   set DONTRUNPLANS [file exists /tmp/PPIXML-DONTRUNPLANS]
   set NOTEMPLATES [file exists /tmp/PPIXML-NOTEMPLATES]
   ## set IGNOREDUMPVERSION [file exists /tmp/PPIXML-IGNOREDUMPVERSION]
   ## RM 10JAN2014 DumpVersion can be a problem before I learn how to read and
   ## store the DumpVersion of each PrProduct/TEC mapped to the same CCI
   ## Zone/Edition so to begin with it is ignored.
   set IGNOREDUMPVERSION 1

   #cmdtrace on notruncate [open /tmp/ppi.debug w]
   set filepath [lindex $args 0]
   set destinationDirectory {}
   set destinationDirectory [lindex $args 1]
   set keepdir {}
   if {[llength $args] > 2} { set keepdir [lindex $args 2] }

   if [file exists $Rejected/[file tail $filepath]] {
      catch {file delete $Rejected/[file tail $filepath]}
   }
   if [file exists $Rejected/[file tail $filepath].status] {
      catch {file delete $Rejected/[file tail $filepath].status}
   }
   set TmpDir [pwd]
   if [file exists $TmpDir/[pid].status] {
      catch {file delete $TmpDir/[pid].status}
   }

   if {[DOM -var pageplans parse $filepath]} {
      LogErr [TransMsg -f PPI-PlanPag.txt -n PARSEFILE \
                       -d "Could not parse file %s" $filepath]
      set errorCode 1
      set errorInfo [TransMsg -f PlanProcessingMailMessages.txt -n PLANPAGXML_FILE_NOT_PARSED_ERRORINFO -d "Could not parse file."]
      set ErrMsg [TransMsg -f PlanProcessingMailMessages.txt -n PLANPAGXML_FILE_NOT_PARSED_ERRORMSG -d "Could not parse file %s." $filepath]
      ReportError $ErrMsg
   } else {
      set filetype [file extension $filepath]
      if [cequal $filetype .rpl] {
         if {[catch { ProcessReply $filepath pageplans } ErrMsg]} {
            set errorCode 2
            set ErrMsg [TransMsg -f PlanProcessingMailMessages.txt -n PLANPAGXML_PROCESSREPLY_FAILED_ERRORMSG -d "Failed to reply to PPI system. Reason: %s." $ErrMsg]
            set errorInfo $ErrMsg
            ReportError $ErrMsg
         }
      } else {
         if [catch { set returnValue [MakeAllPagePlans $destinationDirectory pageplans] } ErrMsg ] {
           set returnValue [list 1 $ErrMsg]
         } 
         if {[lindex $returnValue 0] == 1} {
            set errorCode 3
            set ErrMsg [TransMsg -f PlanProcessingMailMessages.txt -n PLANPAGXML_MAKEALLPAGEPLANS_FAILED_ERRORMSG -d "PPI-PlanPagXML could not convert all plans from PPI to CCI PlanXML format. Reason: %s." $ErrMsg]
            set errorInfo $ErrMsg
            ReportError $ErrMsg
         }

      }
      DOM close $pageplans
   }

   if [file exists $TmpDir/[pid].status] {
      file rename $filepath $Rejected
      file rename $TmpDir/[pid].status $Rejected/[file tail $filepath].status
      if {[llength $PlansNotRun]} {
         return 250
      } else {
         return $errorCode
      }
   } else {
      if [clength $keepdir] {
         catch {file delete $keepdir/[file tail $filepath]}
         file rename $filepath $keepdir
      } else {
         file delete $filepath
      }
      return 0
   }
}
